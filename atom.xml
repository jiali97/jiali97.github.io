<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiali&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-29T23:05:26.170Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xingjiali Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 知识点总结</title>
    <link href="http://yoursite.com/2019/07/26/Java/"/>
    <id>http://yoursite.com/2019/07/26/Java/</id>
    <published>2019-07-26T22:15:12.000Z</published>
    <updated>2019-07-29T23:05:26.170Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/26/Java/Java.png" alt></p><a id="more"></a><blockquote><p>这篇是参考Java快速教程之后的一份学习笔记</p></blockquote><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="Hello-World-到面向对象"><a href="#Hello-World-到面向对象" class="headerlink" title="Hello World 到面向对象"></a>Hello World 到面向对象</h5><ul><li>类(class)：上面程序定义了一个类HelloWorld，该类的名字与.java文件的名字相同。</li><li>方法(method)：类的内部定义了该类的一个方法main。</li><li>语句(statement)：真正的“打印”功能由一个语句实现，即: System.out.println(“Hello World!”);</li><li>使用<code>javac</code>编译，使用<code>java</code>运行</li><li>Java不同变量类型在程序中的内存分布</li></ul><table><thead><tr><th align="center">类型</th><th align="center">存储大小</th><th align="center">例值</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1byte</td><td align="center">3</td><td align="center">字节</td></tr><tr><td align="center">int</td><td align="center">4bytes</td><td align="center">3</td><td align="center">整数</td></tr><tr><td align="center">short</td><td align="center">2bytes</td><td align="center">3</td><td align="center">短整数</td></tr><tr><td align="center">long</td><td align="center">8bytes</td><td align="center">3</td><td align="center">长整数</td></tr><tr><td align="center">float</td><td align="center">4bytes</td><td align="center">1.2</td><td align="center">单精度浮点数</td></tr><tr><td align="center">double</td><td align="center">8bytes</td><td align="center">1.2</td><td align="center">双精度浮点数</td></tr><tr><td align="center">char</td><td align="center">2bytes</td><td align="center">‘a’</td><td align="center">字符</td></tr><tr><td align="center">boolean</td><td align="center">1bit</td><td align="center">true</td><td align="center">布尔值</td></tr></tbody></table><ul><li>Java 数组声明和定义<ul><li>声明：<code>int[] a;</code></li><li>声明的同时使用<code>new</code>来创建数组所需空间：<code>int[] a = new int[100];</code></li><li>声明创建同时指定元素内容：<code>int[] a = new int[]{1,3,5,7,9};</code></li></ul></li><li>表达式<ul><li>数学表达式： +,-,*,/,%</li><li>关系表达式：&gt;,&gt;=,==,&lt;=,&lt;,!=</li><li>布尔表达式：&amp;&amp;,||,!</li><li>位运算：&amp;,|,^,~,&lt;&lt;,&gt;&gt;</li><li>双目表达式：condition? X1:X2</li></ul></li><li>控制结构<ul><li>选择结构<ul><li>if else</li><li>switch</li></ul></li><li>循环结构：<ul><li>while </li><li>do{} while()</li><li>for(){}</li></ul></li><li>break</li><li>continue</li></ul></li></ul><h5 id="方法和数据对象"><a href="#方法和数据对象" class="headerlink" title="方法和数据对象"></a>方法和数据对象</h5><ul><li>Java 使用return来返回值</li><li>this 指代的是对象本身</li><li>成员方法可以添加参数列表</li><li>使用 this.method() 调用同一对象的其他方法</li><li>显式初始化：声明对象时候，对于对象进行赋值</li></ul><h5 id="构造器以及重载"><a href="#构造器以及重载" class="headerlink" title="构造器以及重载"></a>构造器以及重载</h5><ul><li>构造器定义函数值： 类似于C语言中的构造函数</li><li>构建方法 &gt; 显式初始值 &gt; 默认初始值</li><li>Java根据方法名和参数列表决定要调用的方法，叫做方法重载</li></ul><h5 id="封装和接口"><a href="#封装和接口" class="headerlink" title="封装和接口"></a>封装和接口</h5><ul><li>三种不同的封装方法<ul><li>public</li><li>private</li><li>protected： 标记为protected的成员变量在该类和该类的衍生类中可见，但不能被外界访问。</li></ul></li><li>interface 接口<ul><li>interface 可以定义接口</li><li>implements 可以实现接口</li><li>可以实现一个类 实现多个接口</li></ul></li><li>has-a 关系 一个对象可以拥有另一个对象 (手电筒有电池)</li><li>package : 将Java程序代码进行打包，使用包进行访问</li><li>JVM，实现程序的可移植性</li><li>extends 继承<ul><li>新类称之为衍生类</li><li>同名同参数方法会存在方法覆盖</li><li>使用super访问父层的方法</li><li>基类对象先被创建和进行初始化，结束之后，开始构建衍生层(衍生层对象进行创建和初始化)</li></ul></li></ul><h5 id="类数据和类方法"><a href="#类数据和类方法" class="headerlink" title="类数据和类方法"></a>类数据和类方法</h5><ul><li>类数据对象： 所有成员进行共享的变量 使用关键字 static</li><li>类方法：操作类对象的方法使用关键字static, 使用这个关键字的方法不能正常操作属于对象的数据和方法</li><li>对象方法可以访问类数据</li><li>final 关键字：这个数据 / 类 / 方法不能被改变了, private 方法默认为final方法</li></ul><h5 id="接口继承和抽象类"><a href="#接口继承和抽象类" class="headerlink" title="接口继承和抽象类"></a>接口继承和抽象类</h5><ul><li>接口的继承： 和类的继承类似， 可以添加设计更多的方法，不同点，可以实现多重继承</li><li>抽象类：只提供类的原型，不提供类的具体实现。</li></ul><h5 id="Java-对象引用"><a href="#Java-对象引用" class="headerlink" title="Java 对象引用"></a>Java 对象引用</h5><ul><li>new 在内存中为对象开辟了空间，在内存的堆上开辟了空间。</li><li>对象引用存储在内存的栈中</li><li>当我们将一个引用赋值给另一个引用的时候，我们实际上复制的是对象的地址，两个引用将操作同一个对象。当程序通过一个引用修改了对象之后，通过其他引用课也可以看到该修改。</li><li>垃圾回收机制：当一个对象没有引用指向的时候，这个对象就会被清空。</li><li>Java 参数传递：Java的参数传递为值传递。当我们传递一个参数时，方法将获得该参数的一个拷贝。<ul><li>基本对象的参数传递：传递的是值的拷贝，Java方法不会影响到值，形式变量和实际变量。</li><li>引用值的参数传递： 传递的是对象的地址，Java方法会直接影响到对象。</li></ul></li></ul><h5 id="类型转换和多态"><a href="#类型转换和多态" class="headerlink" title="类型转换和多态"></a>类型转换和多态</h5><ul><li>类型检查</li><li>基本类型检查： 收缩类型变换（强制类型转换），宽松变换(自动进行)</li><li>Upcast 和多态：一个衍生类可以转换为其基类引用</li><li>一个衍生类对象可以当做一个基类对象使用</li><li>所有对象都有一个共同的继承祖先，<code>Object</code>类</li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><h5 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h5><ul><li><p>创建字符串 不需要<code>new</code>关键字</p></li><li><p>Java String 类别中的常用方法</p><table><thead><tr><th>方法</th><th>效果</th></tr></thead><tbody><tr><td>s.length()</td><td>返回字符串s的长度</td></tr><tr><td>s.charAt()</td><td>返回字符串中下标为2的字符</td></tr><tr><td>s.substring(0,4)</td><td>返回s字符串中下标0-4的子字符串</td></tr><tr><td>s.indexOf(“Hello”)</td><td>返回子字符串”Hello“的下标</td></tr><tr><td>s.startsWith(“ “)</td><td>返回s是否以空格开始</td></tr><tr><td>s.endsWith(“oo”)</td><td>判断s是否以”oo”结束</td></tr><tr><td>s.equals(“Good World!”)</td><td>判断s是否等于”Good World!”， ==只能判断字符串是否保存在同一位置。需要使用equals()判断字符串的内容是否相同。</td></tr><tr><td>s.compareTo(“Hello Nerd!”)</td><td>比较s字符串与”Hello Nerd!”在词典中的顺序，返回一个整数，如果&lt;0，说明s在”Hello Nerd!”之前；如果&gt;0，说明s在”Hello Nerd!”之后；如果==0，说明s与”Hello Nerd!”相等。</td></tr><tr><td>s.trim()</td><td>去掉s前后的空格字符串，并返回新的字符串</td></tr><tr><td>s.toUpperCase()</td><td>将s转换为大写字母，并返回新的字符串</td></tr><tr><td>s.toLowerCase()</td><td>将s转换为小写字母，并返回新的字符串</td></tr><tr><td>s.replace(“World”, “Universe”)</td><td>将”World”替换为”Universe”，并返回新的字符串</td></tr></tbody></table></li><li><p>String 类型对象是不可变对象</p></li></ul><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><ul><li><code>try</code>, <code>catch</code>, <code>finally</code> 以及其随后的代码段来组成，<code>finally</code> 不是必须的</li><li><code>try</code>后面的程序块包含了针对该异常类型所要进行的操作。<code>try</code>所监视的程序块可能抛出不止一种类型的异常，所以一个异常处理器可以有多个<code>catch</code>模块。<code>finally</code>后面的程序块是无论是否发生异常，都要执行的程序。</li><li>异常都来自与<code>Throwable</code>类，一个<code>Throwable</code>类对象可以抛出，异常分为<code>unchecked</code> 异常和<code>checked</code>异常。</li><li><code>Error</code>是指<code>Java</code>的内部错误或者是资源耗尽等错误，需要直接退出程序。</li><li><code>Exception</code>里面一个衍生类<code>RuntimeException</code> 都是程序自身的问题组成的。</li><li><code>checked</code> 异常，是由编程与环境</li><li>可以自己新建类，在程序中抛出异常</li><li>可以自定义异常，使用继承的方式，需要小心选择所继承的基类。</li></ul><h5 id="运行时类别识别（RTTI）"><a href="#运行时类别识别（RTTI）" class="headerlink" title="运行时类别识别（RTTI）"></a>运行时类别识别（RTTI）</h5><ul><li><code>Class</code>类：对类的抽象和集合。当我们调用对象的<code>getClass()</code>的时候，就会得到其对应<code>Class</code>对象的引用</li><li><code>Class</code>类方法<ul><li><code>getName()</code> 返回类的名字</li><li><code>getPackage()</code>返回类所在的包</li><li><code>getFields()</code>返回所有的public数据成员</li><li><code>getMethods()</code>返回所有的public方法</li></ul></li></ul><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><ul><li>多线程是计算机实现多任务并行处理的一种方式</li><li>单核CPU会在不同的任务之间做切换，这是操作系统分时复用的机制</li><li>多个线程可以并存于同一个进程空间。在JVM的一个进程空间中，一个栈(stack)代表了方法调用的次序。对于多线程来说，进程空间中需要有多个栈，以记录不同线程的调用次序。多个栈互不影响，但所有的线程将共享堆(heap)中的对象。</li><li><code>Thread</code>基类的构造方法可以使用一个字符串作为参数，该字符串是该线程的名字，并使用<code>getName()</code>返回。<ul><li>我们调用线程对象的<code>start()</code> 方法启动线程</li><li><code>join(Thread tr)</code>： 等待线程tr完成</li><li><code>setDaemon()</code>: 设置当前线程为后台daemon</li></ul></li><li>另一种实现多线程的方法是实现<code>Runable</code>接口，并提供<code>run()</code>方法</li><li>Synchronized: 进程之间的同步，防止出现超票的情况<ul><li>我们将共享的资源置于一个对象中</li><li>对于共享资源的操作，放在<code>synchronized</code>方法中</li></ul></li></ul><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><ul><li><p>数组</p><ul><li><p>在说明类型时，在类型说明后面增加一个<code>[]</code>，来说明是一个数组。</p></li><li><p>使用<code>new</code>创建容器时，需要说明数组的大小。我们可以使用 数组名[下标] 的方式来调用某个元素。</p></li><li><p>我们可以逐个的初始化数组的元素，也可以在声明的同时使用<code>{}</code>初始化数组。</p></li><li><p>使用<code>System.arraycopy()</code>方法来有效的复制数组</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(aFrom, <span class="number">1</span>, aTo, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//aFrom为想要复制出去的数组，aTo为想要复制到的数组，1为aFrom的想要复制出去的元素起始位置，0为aTo中想要存储复制来元素的起始位置，3为所要复制的元素总数。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Collection</p><ul><li><code>List</code>  表<ul><li>容器的引用为List类型， 但是容器的实施类型为<code>ArrayList</code>类型。</li><li>将接口和实施做分离</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">add();<span class="comment">//方法加入新的元素</span></span><br><span class="line">get();<span class="comment">//方法可以获取容器中的元素，传递一个整数下标作为参数</span></span><br><span class="line">remove();<span class="comment">//方法可以删除容器中的元素，传递一个整数下标作为参数。(有另一个remove()，传递元素自身作为参数)</span></span><br><span class="line">size();<span class="comment">//方法用来返回容器中元素的总数</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Set</code> 集合</p><ul><li>集合中不允许有等值的元素</li><li>集合的元素没有顺序</li></ul></li><li><p><code>Map</code> 键值对的集合</p><p><img src="/2019/07/26/Java/Java-1.png" alt="Java-1"></p></li><li><p><code>Collection</code></p><ul><li><p>主要方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object o)</span></span>;<span class="comment">//添加对象到集合</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//将指定 collection 中的所有元素都添加到此 collection 中（可选操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//删除集合中所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;<span class="comment">//删除指定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//返回当前集合中元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;<span class="comment">//查找集合中是否有指定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//查找集合中是否有集合c中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">//返回一个迭代器</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>iterator</code> 接口：不论<code>Collection</code> 的实际类型是什么，都支持一个<code>iterator()</code>的方法，该方法返回一个迭代子，使用该迭代子可以逐一访问<code>Collection</code>里面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; <span class="comment">//如果仍有元素可以迭代，则返回True</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>; <span class="comment">//返回下一个迭代的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>; <span class="comment">//将迭代器指向的集合中，移除迭代器返回的最后一个元素</span></span><br></pre></td></tr></table></figure></li><li><p><code>List</code> 接口： 有序的<code>Collection</code>，使用这个接口可以精确的控制每个元素插入的位置，用户可以使用索引（下标的方式）对于对象进行访问。</p><ul><li><code>LinkedList</code> 类：允许<code>null</code>元素，提供额外的<code>get</code>,<code>remove</code>,<code>insert</code> 方法，并不是线程安全的，注意它没有同步方法，需要自己新建。</li><li><code>ArrayList</code>类：实现了一个大小可变的数组，允许<code>null</code>元素，没有同步方法。</li><li>快速添加删除，使用<code>LinkedList</code>，需要快速随机访问元素，使用<code>ArrayList</code>类</li><li><code>Vector</code>类：类似于<code>ArrayList</code>，但是存在的同步方法，是线程安全的，使用<code>Iterator</code>进行遍历操作时候，不同线程对于同一个对象操作会产生异常。`</li><li><code>Stack</code>类：继承自<code>Vector</code>, 实现了一个后进先出的栈，提供5个额外的方法使得<code>Vector</code>能够当做栈来使用，<code>push</code>, <code>pop</code>,<code>peek</code>, <code>empty</code>,<code>search</code>，刚开始创建的时候是空栈。</li></ul></li><li><p><code>Set</code>接口： 不包含重复元素的<code>Collection</code></p><ul><li><code>HashSet</code>: 方法有<code>add()</code>,<code>remove(元素)</code> ，旗下还有实现类<code>LinkedHashSet</code></li><li><code>TreeSet</code>: 是<code>Set</code>的一种变体，可以实现按照树型进行插入，实现元素的排序（从小到大）</li></ul></li><li><p><code>Map</code>接口:  没有实现<code>Collection</code>类，提供从key到value的一种映射。</p><ul><li><p><code>Map</code>接口需要实现的方法有：</p><p>put/putAll/remove/clear  增加删除     </p><p>get/values 获取值</p><p>containKey/containValue 判断</p><p>entrySet/keySet 获取迭代</p><p>equals/hashcode 比较</p></li><li><p><code>HashMap</code> 类: 非进程同步的</p></li><li><p><code>HashTable</code>类：进程同步的</p></li><li><p><code>TreeMap</code>类：<code>Map</code>数据是根据<code>key</code>来进行排序的</p></li></ul></li></ul></li></ul><h5 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h5><ul><li><p>内部类</p><ul><li><p>Java 允许我们在一个类中嵌套另一个类， 在类的内部定义一个新类，这个类称为内部类</p></li><li><p>内部类是被认为是外部对象的一个成员，在定义内部类的时候，同样有访问权限控制（public, private, protected）</p></li><li><p>内部类的默认访问权限是包访问权限，我们可以在外部测试类中访问到对象的内部类，并使用该内部类创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human.Cup soloCup = me.new Cup();</span><br></pre></td></tr></table></figure><p>在创建对象的时候，要注意必须基于一个外部类，并使用这个外部类对象来创建<code>Cup</code>对象。</p></li></ul></li><li><p>闭包</p><ul><li>内部类对象必须依附于某个外部类对象，与此同时，内部类对象也可以访问到它所依附的外部类对象的成员（即便是private成员）。从另一个角度来讲，内部类对象附带有创建对象时的环境信息。</li></ul></li><li><p>嵌套static类</p><ul><li>我们可以定义嵌套的static类，对象不需要依附于外部类的某个对象。相应的，这个嵌套类也无法调用外部对象的方法，也无法读取或者修改外部对象的数据。效果上看，就是扩展了类的命名空间。</li></ul></li></ul><h5 id="GUI-图形界面以及事件响应"><a href="#GUI-图形界面以及事件响应" class="headerlink" title="GUI 图形界面以及事件响应"></a>GUI 图形界面以及事件响应</h5><ul><li>Java GUI 功能主要集中在awt和swing中。awt是GUI的底层包。</li><li>Java Layout 布局方式：Java 里面存在着不同的布局方式。<a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank" rel="noopener">Java布局方式</a></li><li>元素，事件，监听器： 通过监听器，可以将事件绑定在图形元素上面 <code>ActionListener</code>, <code>ActionEvent class</code>  </li></ul><h5 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h5><ul><li><p>Java 是在JVM所虚拟出来的内存环境中运行的。</p></li><li><p>内存分为栈<code>stack</code>和堆<code>heap</code> 两个部分</p></li><li><p>栈</p><ul><li>记录了线程的方法调用，每个线程有一个栈</li><li>如果有新的方法调用，那么栈会增长</li><li>栈的存储单元为帧（frame）</li><li>栈中保存基本变量类型的变量值，以及对象的引用，引用指向堆</li><li>调用结束之后，栈会被释放</li></ul></li><li><p>堆</p><ul><li>堆的空间不会随着方法调用结束而清空，因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。</li></ul></li><li><p>垃圾回收 Garbage Collection (GC)</p><ul><li><p>垃圾回收负责释放不可到达的对象（即没有引用的指向的对象）</p></li><li><p>早期垃圾回收采用引用计数机制，但是存在循环引用不可处理的问题</p></li><li><p>“mark and sweep”： 这种机制下，每个对象将有标记信息，用于表示该对象是否可到达。当垃圾回收启动时，Java程序暂停运行。JVM从根出发，找到所有的可到达对象，并标记(mark)。随后，JVM需要扫描整个堆，找到剩余的对象，并清空这些对象所占据的内存。</p></li><li><p>“copy and sweep”。这种机制下，堆被分为两个区域。对象总存活于两个区域中的一个。当垃圾回收启动时，Java程序暂停运行。JVM从根出发，找到可到达对象，将可到达对象复制到空白区域中并紧密排列，修改由于对象移动所造成的引用地址的变化。最后，直接清空对象原先存活的整个区域，使其成为新的空白区域。</p></li><li><p>这两种机制， “mark and sweep”, “copy and sweep” 都是通过分代回收来进行回收的。</p></li><li><p>每个对象会记录它的世代信息，世代就是指对该对象所经历的垃圾分类回收的次数，世代越久远的对象，在内存中存活的时间就越长。</p></li><li><p><img src="/2019/07/26/Java/generation.png" alt="generation"></p><p>在上图中，堆分为三代，其中永久世代不会被垃圾回收，里面存储的是Class和类相关的信息。年轻世代和成熟世代需要进行垃圾回收。年轻世代需要分为三个区域，第一个区域叫做伊甸，新生对象将存在于这个区域。from, to: 这两个区域大小相等，相当于copy and sweep中的两个区域。当新建对象无法放入eden区时，将出发minor collection。JVM采用copy and sweep的策略，将eden区与from区的可到达对象复制到to区。经过一次垃圾回收，eden区和from区清空，to区中则紧密的存放着存活对象。随后，from区成为新的to区， to区成为新的from区。如果进行minor collection的时候，发现to区放不下，则将部分对象放入成熟世代。另一方面，即使to区没有满，JVM依然会移动世代足够久远的对象到成熟世代。</p></li></ul></li></ul><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://www.cnblogs.com/vamei/archive/2013/03/31/2991531.html" target="_blank" rel="noopener">Java 快速教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/07/26/Java/Java.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network 知识点总结</title>
    <link href="http://yoursite.com/2019/07/23/Computer_Network/"/>
    <id>http://yoursite.com/2019/07/23/Computer_Network/</id>
    <published>2019-07-24T03:00:55.000Z</published>
    <updated>2019-07-27T00:22:39.402Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/23/Computer_Network/Computer_Network.png" alt></p><a id="more"></a><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ul><li>计算机中的二进制数<ul><li>原码：使用最高位表示符号，后面表示数据大小</li><li>补码：正数和原码相同，负数为去除符号位的各位取反，末尾加一得到。（类似于计算机计算中的取模）</li><li>反码：原码各位（除了符号位）取反</li><li>移码：补码，符号位取反</li></ul></li><li>计算机网络定义： 将不同地理位置，具有独立功能的多台计算机及网络设备通过通信线路（包括传输介质和网络设备）连接起来，在网络操作系统，网络管理软件及网络通信协议的共同管理和协调下实现资源共享和信息传递的计算机系统</li><li>计算机网络的基本组成<ul><li>硬件系统：计算机设备，传输介质，网络设备。</li><li>软件系统：操作系统，网络通信协议</li></ul></li></ul><h5 id="互联网体系结构"><a href="#互联网体系结构" class="headerlink" title="互联网体系结构"></a>互联网体系结构</h5><ul><li><p><img src="/2019/07/23/Computer_Network/network_structure.png" alt></p><p><img src="/2019/07/23/Computer_Network/network_function.png" alt></p></li></ul><ul><li><p>五层体系结构（转载自<a href="https://www.cnblogs.com/vamei/archive/2012/11/24/2773967.html" target="_blank" rel="noopener">https://www.cnblogs.com/vamei/archive/2012/11/24/2773967.html</a>）</p><ul><li><p>物理层： 是指光纤、电缆或者电磁波等真实存在的物理媒介。这些媒介可以传送物理信号，比如亮度、电压或者振幅。对于数字应用来说，我们只需要两种物理信号来分别表示0和1，比如用高电压表示1，低电压表示0，就构成了简单的物理层协议。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为0/1序列。</p></li><li><p>连接层：信息以帧(frame)为单位传输。所谓的帧，是一段有限的0/1序列。连接层协议的功能就是识别0/1序列中所包含的帧。比如说，根据一定的0/1组合识别出帧的起始和结束。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。当然，帧中最重要的最重要是所要传输的数据 (payload)。 这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(Type)信息。连接层协议不关心数据中到底包含什么。帧就像是一个信封，把数据包裹起来。数据帧中包括，SRC, DST, 数据，纠错码。Ethernet 以太网和WiFi 是现行的常见的连接层协议。</p></li><li><p>网络层：不同的社区之间该如何通信呢？ 换句话说，如何让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人”。这个“中间人”必须有以下功能: 1. 能从物理层上在两个网络的接收和发送0/1序列，2. 能同时理解两种网络的帧格式。路由器(router)就是为此而产生的“翻译”。一个路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。所以路由器就像是在两个社区都有分支的邮局一个社区的邮差将信送到本社区的邮局分支，而邮局会通过自己在另一个地区的分支将信转交给另一个社区的邮差手中，并由另一个社区的邮差最终送到目的地。</p></li><li><p>传输层：上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求(参看<a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">Linux进程基础</a>和<a href="http://www.cnblogs.com/vamei/archive/2012/10/10/2715398.html" target="_blank" rel="noopener">Linux进程间通信</a>)。这就好像一所房子里住了好几个人(进程)，如何让信精确的送到某个人手里呢？遵照之前相同的逻辑，我们需要在信纸上写上新的信息，比如收信人的姓名，才可能让信送到。所以，传输层就是在信纸的空白上写上新的“收信人”信息。每一所房子会配备一个管理员(传输层协议)。管理员从邮差手中接过信，会根据“收信人”，将信送给房子中的某个人。 传输层协议，比如TCP和UDP，使用端口号(port number)来识别收信人(某个进程)。在写信的时候，我们写上目的地的端口。当信到达目的地的管理员手中，他会根据传输层协议，识别端口号，将信送给不同的人。TCP和UDP协议是两种不同的传输层协议。UDP协议类似于我们的信件交流过程。TCP协议则好像两个情人间的频繁通信。一个小情人要表达的感情太多，以致于连续写了好几封信。而另一方必须将这些信按顺序排列起来，才能看明白全部的意思。TCP协议还有控制网络交通等功能。</p></li><li><p>应用层：通过上面的几层协议，我们已经可以在任意两个人(进程)之间进行通信。然而每个人实际上从事的是不同的行业。有的人是律师，有的人外交官。比如说律师之间的通信，会用严格的律师术语，以免产生纠纷。再比如外交官之间的通信，必须符合一定的外交格式，以免发生外交误会。再比如间谍通过暗号来传递加密信息。应用层协议是对信件内容进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。</p></li></ul><p>整个通信过程如下:</p><p>WiFi上的计算机1-&gt;路由WiFi接口-&gt;  路由以太网接口-&gt; 以太网上的计算机2</p><p>(蓝色表示WiFi网络，绿色表示以太网络)</p><p>在连接层，我们的一个帧中只能记录SRC和DST两个地址。而上面的过程需要经过四个地址 (计算机1，WiFi接口，以太网接口，计算机2)。显然，仅仅靠连接层协议无法满足我们的需要。由于连接层协议开发在先，我们无法改动连接层协议，只能在连接层的数据(payload)，也就是信纸内部下功夫了。IP协议应运而生。</p><p>计算机1，路由器和计算机2都要懂得IP协议。当计算机1写信的时候，会在信纸的开头写上这封信的出发地址和最终到达地址 (而不是在信封上)，而在信封上写上要送往邮局。WiFi网的邮差将信送往邮局。在邮局，信被打开，邮局工作人员看到最终地址，于是将信包装在一个新的信封中，写上出发地为邮局，到达地为计算机2，并交给以太网的邮差，由以太网的邮差送往计算机2。</p><p>所以邮局要求，信纸上写的地址必须是一个符合官方规定的“邮编”，也就是IP地址。这个地址为世界上的每一个房子编号(邮编)。当信件送到邮局的时候，邮局根据邮编，就能查到对应的地址描述，从而能顺利改写信封上的信息。</p><p>每个邮局一般连接多个社区，而一个社区也可以有多个邮局，分别通往不同的社区。有时候一封信要通过多个邮局转交，才能最终到达目的地，这个过程叫做route。邮局将分离的局域网络连接成了internet，并最终构成了覆盖全球的互联网。</p></li></ul><h5 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h5><ul><li><p>连接层协议：Ethernet 以太网协议和WiFi协议</p><ul><li>Ethernet 以太网协议</li></ul><ul><li>头部（preamble，SFD 起始信号，DST 目的地，SRC 发出地，Type 类型）<ul><li>数据 （IP包）</li></ul></li><li>尾部（FCS校验和（使用CRC校验））<ul><li>集线器（Hub）：广播式传播，不允许冲突，需要添加冲突处理算法。</li></ul></li><li>交换机（Switch）:只向特定的网络接口中传播数据。</li></ul><ul><li>WiFi 协议(802.11协议)</li></ul></li><li><p>网络层协议：</p><ul><li>网卡： 网卡（Network Interface Card) 是计算机中的一个硬件，在接收到了网络信息之后，将信息交给计算机，当计算机需要发送信息的时候，也通过网卡发送。</li><li>路由器：就是配有多个网卡的硬件，帮助网卡接入不同的网络中。</li><li>IP协议： 不可靠。不能保证按序到达。<ul><li>IPv4 =&gt; IPv6: 地址耗尽的危机</li><li>Version, Source Address, Destination Address: IP 协议版本，出发地IP和目的地IP</li><li>Time to live =&gt; Hop Limit : 表示一个IP包的最大存活时间</li><li>Type of Service =&gt; Traffic Class: 为包分优先级， 后被分为Differentiated Service Field (DS, 前6位)和 Explicit Congestion Notification (ECN, 后2位)</li><li>Protocol =&gt; Next Header: 包中所包含的协议是什么</li><li>IHL 记录头部长度，Total Length =&gt; Payload Length 表示IPv6数据部分的长度。</li><li>Header Checksum：校验IP头部信息。</li><li>Identification, flags和fragment offset: 为包的碎片化准备，包传播路径上面有MTU(最大传输单元)</li><li>Flow Label (IPv6 中新增)： 提醒路由器来重复之前的接力路径，这样IP包可以保持出发的顺序。</li></ul></li><li>RIP 协议(Routing Information Protocol)：通过距离来决定routing table. 通常在一个自治系统中使用。</li><li>BGP 协议(Boarder Gateway Protocol)：不同的 AS 相互沟通的协议。</li><li>为了应对地址不够用的危机，使用CIDR无类域间路由进行网络扩展，相当于每个IP多了一个配套的子网掩码。</li><li>NAT协议<ul><li>基础NAT协议</li><li>NATP协议</li></ul></li></ul></li><li><p>介于网络层和传输层之间的协议：ICMP 协议， 主要作用是传输网络诊断信息。</p><ul><li><p>ARP协议用于发现周边的IP地址和MAC地址的对应。然而，ARP协议只用于IPv4，IPv6并不使用ARP协议。IPv6包通过邻居探索(ND, Neighbor Discovery)来实现ARP的功能。ND的工作方式与ARP类似，但它基于ICMP协议。ICMP包有Neighbor Solicitation和Neighbor Advertisement类型。这两个类型分别对应ARP协议的询问和回复信息。</p></li><li><p>传递错误信息和咨询信息。ICMP协议是基于IP协议的。是实现ping命令和traceroute命令的基础。</p></li><li><p>常见的ICMP包类型</p><ul><li>回音：Echo-询问类型包，Echo-回答类型包</li><li>源头冷却：提醒主机减慢发包速度。</li><li>目的地无法到达：可能不存在合适的路由或者是相对应接口没有开启。</li><li>超时：TTL减为0的时候，发生的错误就是超时错误。</li><li>重定向: 当一个路由器收到了一个IP包，对照其routing table,发现自己不应该收到该IP包，它会向主机发送重新定向类型的ICMP, 提醒出发主机修改自己的routing table.</li></ul></li></ul></li><li><p>传输层协议</p><ul><li><p>UDP协议： 和IP协议非常相似，不可靠的，以数据包形式传输。</p><ul><li>UDP分为头部，和数据部分两个部分。</li><li>UDP头部包括source port，destination port，Length 以及 Checksum 四个部分。</li><li>可以调用操作系统中的API，来构建socket。Socket是操作系统提供的一个编程接口，它用来代表某个网络通信。</li></ul></li><li><p>TCP协议：传输层的流协议。可靠的协议。双向的。</p><ul><li><p>滑动窗口协议代替单纯的stop and wait 协议：传输(Seq),等待(Ack)</p></li><li><p>TCP需要两个IP，两个端口确定谁和谁在说话。同一个端口上可能有很多个连接。 </p></li></ul></li></ul></li><li><p>应用层协议</p><ul><li>基于TCP：FTP(文件传输协议，端口21)，Telnet(远程登录，支持BBS，端口23)， SMTP(简单邮件传输协议，端口25)，POP3(用于接受邮件的协议，端口110)，HTTP(超文本传输协议)</li><li>基于UDP：DNS(域名解析协议，端口53)， SNMP(简单网络管理协议，端口161)，TFTP(简单文件传输协议，端口69)</li></ul></li></ul><h5 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h5><ul><li><p>TCP头部</p><p><img src="/2019/07/23/Computer_Network/tcpheader.png" alt></p></li><li><p>TCP 连接</p><ul><li><p>每个TCP片段都有自己的序号，ACK是一位，只有ACK设定的时候，回复号才生效，许多ACK回复的时候，是附着在其双向的连接中，也可以附着在SYN和FIN片段中。</p></li><li><p>TCP三次握手</p><p>ISN 交换 (Initial Sequence Number)</p><p><img src="/2019/07/23/Computer_Network/tcp_open.png" alt></p><p>青色为纯粹的ACK片段。整个过程的本质是双方互发含有自己的ISN的SYN片段。根据TCP传输的规则，接收到ISN的一方需要回复ACK，所以共计四片信息在建立连接过程中传输。之所以是三次握手 (而不是四次)，是因为server将发送SYN和回复ACK合并到一个TCP片段中。我们以client方为例。client知道自己的ISN(也就是ISN(c))。建立连接之后，它也知道了对方的ISN(s)。此后，如果需要发送文本流片段，则编号为ISN(c) + 1, ISN(c) + 2 …。如果接收文本流片段，则期待接收ISN(s) + 1, ISN(s) + 2 …。连接建立之后，连接的双方就可以按照TCP传输的方式相互发送文本流了。</p></li><li><p>TCP 四次挥手 连接终结</p><p><img src="/2019/07/23/Computer_Network/tcp_close.png" alt="image-20190723154819723"></p><p>一个连接建立之后，连接两端的进程可以利用该连接进行通信。当连接的一方觉得“我讲完了”，它可以终结连接中发送到对方方向的通信。连接最终通过四次握手(four-way handshaking)的方式终结，连接终结使用的是特殊片段FIN(FIN位为1的片段)。</p><p>我们可以看到，连接终结的过程中，连接双方也交换了四片信息(两个FIN和两个ACK)。在终结连接的过程中，TCP并没有合并FIN与ACK片段。原因是TCP连接允许单向关闭(half-close)。也就是说，TCP连接关闭了一个方向的传输，成为一个单向连接(half-duplex)。第二个箭头和第三个箭头传递必须分开，才能有空隙在开放的方向上继续传输。如果第二个箭头和第三个箭头合并在一起，那么，随着一方关闭，另一方也要被迫关闭。</p><p>第二和第三次握手之间，server可以继续单向的发送片段给client，但client不能发送数据片段给server。(上面的终结从client先发起，TCP连接终结也可以从server先发起。)在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p></li></ul></li></ul><p><img src="/2019/07/23/Computer_Network/tcp.png" alt></p><ul><li><p>实现无差错的传输方案</p><ul><li><p>滑动窗口概念：自动重传请求协议（ARQ）为了方便存在自动重传协议（ARQ）</p></li><li><p><img src="/2019/07/23/Computer_Network/ARQ_protocol.png" alt></p></li></ul></li><li><p>TCP 流量控制(flow control)：接收方将advertised window size 通知发送方。发送方在收到window size的通知时，会调整自己的滑窗大小，使得发送速率降低，这样来减轻接收方的负担。出现零窗口的时候，发送方会不断探测接收方的窗口，窗口探测的时候，发送方会发送1byte大小的TCP片段，并且等待ACK回复(里面包含Win Size) </p></li><li><p>白痴窗口综合症 (Silly Window Syndrome) : 通信双方传输包含通信数据量很少，TCP头部的控制信息很多的情况。为了解决这个问题，需要从两方面入手。TCP中有相关的规定，要求：</p><ol><li><p>接收方宣告的窗口必须达到一定的尺寸，否则等待。</p></li><li><p>除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的TCP应用(比如命令行互动)。</p></li></ol></li><li><p>TCP重新发送机制</p><ul><li>TCP超时重传机制：重新发送超时时间(RTO, retransmission timeout），TCP协议中，通过采样RTT来得到合适的RTO时间</li><li>TCP快速重传机制：收到三次duplicate Ack的时候，发出方认为接收方没有收到，就进行重新传送之前没有传送的片段。</li></ul></li><li><p>TCP拥塞控制机制: 防止过多的数据注入到网络中，使得网络中的路由器和链路过载。</p><ul><li><p>TCP通过维护 Congestion Window Size 来进行拥塞控制。真实的滑窗大小取这两个的最小值，来满足拥塞控制和流量控制的要求。</p></li><li><p>TCP拥塞控制有这样四个算法</p><ul><li>slow start, congestion avoidance</li></ul></li></ul></li></ul><ul><li><p>快重传和快恢复算法</p></li><li><p>TCP的拥塞控制处于这样两个不同的状态，slow start 和 拥塞避免 congestion avoidance</p><p><img src="/2019/07/23/Computer_Network/congestionControl.png" alt></p><p>Congestion window从slow start的状态开始。Slow start的特点是初始速率低，但速率不断倍增。每次进入到slow start状态时，cwnd都需要重置为初始值1。发送方每接收到一个正确的ACK，就会将congestion window增加1，从而实现速率的倍增(由于<a href="http://www.cnblogs.com/vamei/archive/2012/12/18/2822739.html" target="_blank" rel="noopener">累计ACK</a>，速率增长可能会小于倍增)。</p><p>当congestion window的大小达到某个阈值ssthresh时，congestion进入到congestion avoidance状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，将窗口尺寸增加1(实际上就是每个RTT增加1)。所以在congestion avoidance下，cwnd线性增长，增长速率慢。</p><p>  如果在congestion avoidance下有片段丢失，重新回到slow start状态，并将ssthresh更新为cwnd的一半。我们看到，sshthresh是slow start到congestion avoidance的切换点。而片段丢失是congestion avoidance到slow start的切换点。一开始sshthresh的值一般比较大，所以slow start可能在切换成congestion avoidance之前就丢失片段。这种情况下，slow start会重新开始，而ssthresh更新为cwnd的一半。</p><p>  总的来说，发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。</p><p>  拥塞控制存在不同的算法，来进行协调和调整。</p><p>  <img src="/2019/07/23/Computer_Network/congestion_control.png" alt></p></li><li><p>TCP粘包问题和nagle算法：发送端为了将数据更有效的发送到接收端，使用了优化算法nagle算法，将多次间隔较小的包且数据量较小的包合并成一个包，进行封包，这样的话，要求接收端采用合适的算法进行拆包。</p></li></ul><h5 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h5><ul><li>DNS协议是基于UDP的，DNS服务器中存储了域名和IP的关系。</li><li>DNS协议进行查找的时候，是按照域名中的顺序，一级一级的进行查找。</li><li>DNS Cache 缓存，在进行查找之前，计算机会先查询cache中是否有相关的记录。</li><li>反向DNS，和DNS的顺序相反，提供IP所对应的域名。</li></ul><h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h5><ul><li><p>HTTP 报文</p><ul><li>基本格式：起始行（start line），头信息(headers) 空行 主体信息</li><li>起始行只有一行，请求表示求什么，回复表示发生什么。</li><li>头信息是多行，每一行都是键值对。</li><li>主体部分表示包含的具体资源。</li></ul></li><li><p>HTTP 状态码</p><ul><li>2xx 成功： 200 成功</li><li>3xx 重定向： 301 永久移动 302 临时移动</li><li>4xx 请求错误：404 未找到</li><li>5xx 服务器错误： 500 服务器内部错误</li></ul></li><li><p>HTTP 1.0 和 1.1 的区别</p><ul><li>引入了持久连接，在同一个TCP连接中可以传输多个<code>HTTP</code>请求和响应</li><li>多个请求和响应可以同时进行&amp;可以重叠</li><li>引入了更多的请求头和响应头</li></ul></li><li><p>HTTP 请求方法</p><ul><li>OPTIONS，HEAD， GET（请求的参数需要放置在URL中），POST（向指定资源提交数据进行处理请求），PUT(向指定资源位置上传新内容)，DELETE(请求服务器删除指定资源)，TRACE(回显收到的请求)，</li><li>GET请求和POST请求区别：URL上面回显，数据安全性，幂等性。</li></ul></li><li><p>HTTP 请求过程</p><ul><li>客户端连接到Web服务器：浏览器与Web服务器建立TCP连接</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放TCP连接：connection模式为close, 服务器主动关闭TCP连接； connection 模式为keepalive，则连接会维持一会儿</li></ul></li><li><p>HTTP 长连接和短连接</p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><img src="http_connection.png" alt></p></li><li><p>转发和重定向的区别：转发是服务器的行为，重定向是客户端的行为</p></li><li><p>Cookie  &amp; Session &amp; Token </p><ul><li>Cookie: 一种客户端机制<br><img src="/2019/07/23/Computer_Network/Cookie.png" alt><ul><li>为了辨别用户身份，进行session追踪而储存在本地客户端上面的数据（通常加密）</li><li>分为内存cookie (浏览器关闭后就消失了)，硬盘cookie（存在过期时间，超时或者用户手动清理）</li></ul></li></ul></li></ul><ul><li>持久性Cookie和非持久性Cookie</li><li>Session: 代表服务器和客户端一次会话过程，过程可以是连续的，可以是断续的。Session由服务器端生成并进行保存。<ul><li>判断用户是否登录 &amp; 购物车功能</li><li>Token:<br><img src="/2019/07/23/Computer_Network/Token.png" alt><ul><li>Token 由服务器返回给客户端，之后客户端每次请求都必须带上Token, 服务器端进行验证Token的有效性。</li></ul></li></ul></li></ul><h5 id="DHCP协议-动态主机配置协议"><a href="#DHCP协议-动态主机配置协议" class="headerlink" title="DHCP协议 (动态主机配置协议)"></a>DHCP协议 (动态主机配置协议)</h5><ul><li>要求： 地址合法和地址空闲</li><li>过程：Discovery(客户机广播)，Offer(DHCP服务器发出邀请，提供一个可用的IP地址)，Request(客户机正式请求使用该地址)，Acknowledge(DHCP服务器确认，并提供更多的参数)</li><li>其他网络配置信息，DNS服务器地址，网络出口地址</li><li>DHCP攻击： 拒绝攻击（DHCP耗尽攻击），伪造恶意的DHCP服务（中间人攻击，借助ARP欺诈），</li></ul><h5 id="SSL-TLS-协议"><a href="#SSL-TLS-协议" class="headerlink" title="SSL/TLS 协议"></a>SSL/TLS 协议</h5><ul><li><p>对称加密和非对称加密：使用相同的密匙或者使用不同的密匙。公私钥加密。</p></li><li><p>SSL协议: 使用非对称加密加密对称加密的密匙，使用对称加密的密匙加密传输的数据。</p><p>SSL协议的关键是用一个非常安全的方式来交换一个对称密钥。交换的过程会比上面的描述更加复杂一些。</p><ul><li>客户发起请求时，除了说明自己支持的非对称加密算法，还会附加一个客户端随机数(client random)。</li><li>服务器回复请求时，会确定非对称加密算法和哈希函数，并附上公钥。此外，服务器端还会在此次通信中附加一个服务器端随机数(server random)。</li><li>客户端会产生第三个随机数(Premaster secret)，然后利用服务器确定的非对称加密算法和公钥来加密这个随机数，再发送给服务器端。</li><li>客户端用自己的私钥解密第三个随机数。<br>这样，客户端和服务器端都知道了三个随机数。双方各自用商量好的哈希函数从三个随机数获得对称加密的密钥。</li></ul></li><li><p>HTTP 和 HTTPS 区别：</p><ul><li>HTTPS协议是由SSL+HTTP两个方面构建的可进行加密传输，身份认证的网络协议。相对于HTTP协议，HTTPS协议更加的安全。</li><li>HTTPS协议需要申请证书，一般的CA证书都需要收费。</li><li>HTTPS和HTTP使用不同的端口，HTTP使用80端口，HTTPS使用443端口。</li><li>HTTP工作在应用层，而HTTPS工作在传输层。</li></ul></li><li><p>https 通信过程</p><ul><li>A 与B 通过TCP 建立链接，初始化SSL 层。</li><li>进行SSL 握手，A 发送https 请求，传送客户端SSL 协议版本号、支持的加密算法、随机数等。</li><li>服务器B 把CA 证书（包含B 的公钥），把自己支持的加密算法、随机数等回传给A。</li><li>A 接收到CA 证书，验证证书有效性。</li><li>校验通过，客户端随机产生一个字符串作为与B通信的对称密钥，通过CA证书解出服务器B的公钥，对其加密，发送给服务器。</li><li>B 用私钥解开信息，得到随机的字符串（对称密钥），利用这个密钥作为之后的通信密钥。</li><li>客户端向服务器发出信息，指明后面的数据使用该对称密钥进行加密，同时通知服务器SSL 握手结束。</li><li>服务器接收到信息，使用对称密钥通信，通知握手接收。</li><li>SSL 握手结束，使用对称密钥加密数据。</li></ul></li><li><p>SSL工作原理：握手协议，警报协议，记录协议。</p></li></ul><h5 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h5><ul><li><p>SYN flood 攻击：给服务器发送了一个SYN之后就下线了，服务器需要等待63s之后才会断开连接，这样就会把主机的SYN连接给耗尽。使用三个参数进行处理，tcp_synack_retries 可以减少重试次数, tcp_max_syn_backlog, 可以增加SYN的连接数，tcp_abort_on_overflow处理不过来直接选择放弃。</p><ul><li>服务器的TCP资源分配时刻 = 完成第二次握手时，客户段进行TCP资源分配时刻在完成第三次握手时</li><li>攻击端利用伪造的IP地址向被攻击端进行攻击请求，而得到的报文不能发送到源地址，这样来耗尽服务器的资源，从而达到了攻击的目的。</li></ul></li><li><p>DDos 攻击：攻击者通过路由器发送海量的信息请求和畸形报文，导致CPU无法实时处理消息，引发正常的业务交互流程，内部处理流程阻塞，达到拒绝服务的目的。</p></li><li><p>DNS 欺诈：攻击者冒充域名服务器的一种行为。主要类别有主机host文件修改，本机DNS劫持。</p></li><li><p>ARP 投毒：通过分别伪装成客户机和服务器IP，将自己的MAC地址绑定在IP上，ARP错误的将IP解析为中间人MAC地址，从而来欺骗服务器网关和客户机，使信息必须通过客户机。</p></li><li><p>Replay 攻击：攻击者发送目标主机已接受的包，来达到欺骗系统的目的，主要用于身份认证的过程中，破坏认证的正确性。防范：加时间戳或者随机数。</p></li><li><p>Web Security</p><ul><li><p>SQL注入</p><ul><li>通过把SQL语句插入到Web表单提交或者是域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL语句的作用。</li><li>防范：加密处理输入，确保数据库安全（给予用户最低权限），输入验证（对于输入进行验证），参数分离，对于输入进行正则匹配验证。</li></ul></li><li><p>CSRF跨站请求伪造</p><ul><li>钓鱼网站盗用了被害者的身份信息，强调的是盗用</li><li>常见防护方法： 验证HTTP reference 字段；添加随机生成的Token字段；使用验证码；尽量使用POST进行请求，不使用GET进行请求；HTTP头添加自定义属性。</li></ul></li><li><p>XSS 跨站脚本攻击： <a href="https://thief.one/2017/05/31/1/" target="_blank" rel="noopener">https://thief.one/2017/05/31/1/</a></p><ul><li><p>页面被插入了恶意脚本</p></li><li><p>类别：反射型XSS，存储型XSS(存储在云端服务器)，DOM型</p></li><li><p>危害: cookie劫持，后台进行增删查改等操作，钓鱼，XSS蠕虫，修改网页代码，利用网站进行重定向，获取用户信息。</p></li><li><p>XSS探针: <code>&#39;&#39;;!--&quot;&lt;XSS&gt;=&amp;{()}</code></p></li><li><p>防御： </p><ul><li>可在cookie中设置httponly（浏览器禁止页面的js访问带有httponly属性的cookie）</li><li>xss filter（检查输入，设置白名单方式）</li><li>输出检查（编码，转义，常用编码：html编码，js编码，16进制等)</li><li>针对不同位置的输出，使用不同的处理方式</li><li>处理富文本</li><li>header中使用content-Sencurity-Policy字段，规定请求js的域名白名单（CSP策略）</li></ul></li></ul></li></ul></li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>浏览器中输入URL发生了什么<ul><li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器</li><li>浏览器向IP对应的web服务器发送一个HTTP请求</li><li>服务器响应请求，发回网页内容</li><li>浏览器解析网页内容</li></ul></li></ul><ul><li>网络命令<ul><li>ifconfig: 显示网络接口信息，如接口名称，接口类型，接口的IP地址，硬件的MAC地址等等。</li><li>arp -a: 显示本地存储的IP-MAC对应关系</li><li>sudo arp-scan -l：查询整个局域网内的所有IP地址的对应MAC地址</li><li>sudo tcpdump -i en0 arp：监听en0接口的arp协议通信</li><li>ping：是向某个IP地址发送ICMP协议的ECHO_REQUEST请求。收到该请求的设备，将返回ICMP回复。如果ping到某个IP地址，那么说明该IP地址的设备可以经网络层顺利到达</li><li>sudo ipconfig set en0 DHCP：更新DHCP租约。设备将释放IP地址，再从DHCP服务器重新获得IP地址。</li><li>netstat -nr: 显示路由表</li><li>traceroute 74.125.128.99：追踪到达IP目的地的全程路由</li><li>tcpdump是一款网络抓包工具。它可以监听网络接口不同层的通信，并过滤出特定的内容，比如特定协议、特定端口等</li><li>域名解析，调用DNS解析查看对应IP地址：host <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></li></ul></li><li>CDN （Content Delivery Network）内容分发网络<ul><li>定义：CDN，英文Content Delivery Network，中文翻译是内容分发网络，目的就是通过现有的Internet 中增加一新的网络架构，将网站内容发布到离用户最近的网络“边缘”，提高用户访问网站的速度，所以更像是增加了一层CACHE（缓存）层。</li><li>功能：当用户访问加入CDN 服务的网站时，域名解析请求将最终交给全局负载均衡DNS 进行处理。全局负载均衡DNS 通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。</li><li>组成：每个CDN 节点由两部分组成：负载均衡设备和高速缓存。</li></ul></li></ul><ul><li>参考资料<ul><li><a href="https://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html" target="_blank" rel="noopener">协议森林</a></li><li><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e" target="_blank" rel="noopener">搞定计算机网络面试</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/07/23/Computer_Network/Computer_Network.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
</feed>
