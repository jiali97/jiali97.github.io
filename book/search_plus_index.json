{"./":{"url":"./","title":"Introduction","keywords":"","body":"LeetCode Solutions Solving for Fun "},"LinkedList.html":{"url":"LinkedList.html","title":"Linked List","keywords":"","body":"Linked List 常见技巧总结 tagsstart Linked List tagsstop 只要涉及到处理头结点的时候，都可以通过增添哑结点，使得操作head节点和其他节点无异 找到链表中的一个特定位置的时候，可以使用快慢指针的方法 交换两个节点的注意事项 先交换两个前驱节点的next指针的值 再交换这两个节点的next指针的值 修改单链表的时候注意事项 哪个节点的next指针受到影响，需要修改该指针 操作链表的时候注意边界条件 同时操作两个链表的注意事项 循环条件可以是while list1 && list2 当循环跳出的时候，再处理剩下非空的链表 倒序访问链表 可以使用递归或者是栈来进行等效处理 Java 中链表的实现类 LinkedList\\ add(E e) add(int index, E e) remove(int index) addAll(Collection c) get(int index) Reference: 《程序员面试白皮书》 "},"BinarySearch.html":{"url":"BinarySearch.html","title":"Binary Search","keywords":"","body":"Binary Search 常用技巧总结 tagsstart Binary Search tagsstop 注意事项 溢出： 取值时候需要防止溢出 边界错误：需要注意的是，循环体外的初始化条件，循环体内部的迭代步骤，都必须遵循一致的区间规则 死循环：错误的边界，使得不能从循环中正确退出。 第一类：需要查找的值和目标值完全相同 写法一： 左闭右开区间: 注意right取值始终是在范围之外的值 def find(arr, target): left, right = 0, len(arr) while left 写法二： 全部闭区间：注意right取值在范围之内 def find(arr, target): left, right = 0, len(arr) - 1 while left 第二类：查找第一个不小于目标值的位置，或者查找最后一个小于目标值的位置 需要查找的数值在数组中并不一定出现，或者出现但是并不一定唯一。 def binarysearch(arr, target): left, right = 0, len(arr) while left 变形只需要修改返回值，返回right-1 即可 第三类：查找第一个大于目标值的数，可以变形为查找最后一个不大于目标值的数 def binarysearch(arr, target): left, right = 0, len(arr) while left Reference https://www.cnblogs.com/grandyang/p/6854825.html https://blog.csdn.net/yefengzhichen/article/details/52372407 https://segmentfault.com/a/1190000016825704 https://www.1point3acres.com/bbs/thread-432793-1-1.html "},"1.html":{"url":"1.html","title":"1 Two Sum","keywords":"","body":"1 Two Sum tagsstart Array Hash Table tagsstop Method 1: 双重for循环，判断是否想加等于target 时间复杂度：O(n^2) Method 2: 使用hash记录已经循环过的值，每次判断target-current O(n) Python class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" length = len(nums) for i in range(length): for j in range(i+1,length): if nums[i] + nums[j] == target: return [i,j] class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" hash = {} length = len(nums) for i in range(length): if target - nums[i] in hash: return [hash[target-nums[i]], i] else: hash[nums[i]] = i C++ class Solution { public: vector twoSum(vector& nums, int target) { unordered_map m; vector result; for(int i = 0; i Java class Solution { public int[] twoSum(int[] nums, int target) { Map map = new HashMap<>(); for(int i = 0; i "},"2.html":{"url":"2.html","title":"2 Add Two Numbers","keywords":"","body":"2 Add Two Numbers tagsstart Linked List Math tagsstop 链表的基本操作，注意记录carry, while循环需要写上循环出来的条件，第一遍循环结束之后，记录下rest, 使用哑结点，方便之后的操作，可以避免判断， 时间复杂度O(n) Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" cur, carry = 0, 0 head = ListNode(0) curNode = head while l1 or l2: x = l1.val if l1 else 0 y = l2.val if l2 else 0 cur = x + y + carry carry = cur / 10 cur = cur % 10 curNode.next = ListNode(cur) curNode = curNode.next if l1: l1 = l1.next if l2: l2 = l2.next if carry: curNode.next = ListNode(carry) curNode = curNode.next return head.next Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while(p != null || q != null){ int x = (p!=null) ? p.val: 0; int y = (q!=null) ? q.val: 0; int sum = x + y + carry; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if(p!= null) p = p.next; if(q!= null) q = q.next; } if (carry > 0){ curr.next = new ListNode(carry); } return dummyHead.next; } } "},"3.html":{"url":"3.html","title":"3 Longest Substring Without Repeating Characters","keywords":"","body":"3 Longest Substring Without Repeating Characters tagsstart Hash Table Two Pointers String Sliding Window tagsstop Method 1: Brute force try every point as start and end, 判断中间的有没有重复元素, 循环 start 和 end 的位置。时间复杂度：O(n^3) Method 2: Sliding windows. Keep the begin pointer and the end pointer to indicate the start position and the end position. Using hash table to store information. 注意事项：previousPosition >= start 才需要变动start的位置。 class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" if s == '': return 0 ans = 1 for i in range(len(s)): subs = s[i] for j in range(i+1,len(s)): if s[j] not in subs: subs += s[j] else: break if len(subs)>ans: ans = len(subs) return ansCopy class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" if s == \"\": return 0 length = len(s) start = 0 ans = 1 hash = {} for end in range(len(s)): ch = s[end] if ch not in hash: if end - start + 1 > ans: ans = end - start + 1 else: previousPosition = hash[ch] if previousPosition >= start: start = previousPosition + 1 if end - start + 1 > ans: ans = end - start + 1 hash[ch] = end return ans "},"4.html":{"url":"4.html","title":"4 Median of Two Sorted Arrays","keywords":"","body":"4 Median of two Sorted Arrays tagsstart Array Binary Search Divide and Conquer tagsstop Method 1: Merge two sorted arrays into one, then use index to find the median element. O(m+n ) Method 2: Binary search. Delete half of the data once. O(log(m+n)) 使用 Binary Search的时候，可以考虑以找到左边数组中需要元素的个数作为二分搜索的条件。代码来源于花花酱的博客，花花的视频讲题真的超级优秀！！所有资源在Youtube上面公开，算是很良心啦。 Python class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" merge_arr = [] p1, p2 = 0, 0 len1, len2 = len(nums1), len(nums2) while True: if p1 class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" n = len(nums1)+len(nums2) if n%2 == 1: return self.findKth(nums1,nums2,n/2+1) else: smaller = self.findKth(nums1,nums2,n/2) bigger = self.findKth(nums1,nums2,n/2+1) return (smaller + bigger)/2.0 def findKth(self, A, B, k): # print A, B, k if len(A) == 0: return B[k-1] if len(B) == 0: return A[k-1] if k == 1: return min(A[0],B[0]) a = A[k/2-1] if len(A) >= k/2 else None b = B[k/2-1] if len(B) >= k/2 else None if a is None: return self.findKth(A,B[k/2:],k-k/2) if b is None: return self.findKth(A[k/2:],B,k-k/2) if(a>b): return self.findKth(A,B[k/2:],k-k/2) else: return self.findKth(A[k/2:],B,k-k/2) Java class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n1 = nums1.length; int n2 = nums2.length; if(n1 > n2) return findMedianSortedArrays(nums2, nums1); int k = (n1 + n2 + 1)/2; int l = 0; int r = n1; while(l = n1 ? Integer.MAX_VALUE : nums1[m1], m2 >= n2 ? Integer.MAX_VALUE : nums2[m2]); return 0.5*(c1 + c2); } } } Java 小技巧 两数中最大最小值： 使用Math包中的max函数和min函数 整数中最大最小值：使用Integer包中的MAX_VALUE和MIN_VALUE，类中的静态成员（类成员不会变动） "},"5.html":{"url":"5.html","title":"5 Longest Palindromic Substring","keywords":"","body":"5 Longest Palindromic Substring tagsstart String Dynamic Programming tagsstop Method 1: Brute Force=> Pick all possible starting and ending positions, and then verify it is palindromic. O(n^3) Method 2: DP => dp[i][j] (true if s[i][j] is palindromic and false if s[i][j] is not palindromic) Method 3: Try each middle points and find the longest one. class Solution: def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" ans = s[0] inc = 0.5 while inc =0 and s[int(inc + j)] == s[int(inc - j)]: tmp = s[int(inc - j)] + tmp + s[int(inc + j)] j = j + 1 if len(ans) "},"6.html":{"url":"6.html","title":"6 ZigZag Conversion","keywords":"","body":"6 ZigZag Conversion Method: Store the information according to their layer. Use extra value to store the direction and the current layer value. 注意： 如果numRows == 1 没有必要进行conversion 这个情况单独列出来一下 class Solution(object): def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\" if numRows == 1: return s d = [ \"\" for i in range(numRows)] current_row = 0 current_direction = -1 for i in s: print current_row d[current_row] += i if current_row == 0 or current_row == numRows - 1: current_direction *= (-1) current_row += current_direction ans = \"\" for i in d: ans += i return ans "},"7.html":{"url":"7.html","title":"7 Reverse Integer","keywords":"","body":"7 Reverse Integer tagsstart Math tagsstop Method: 简单模拟，注意几种情况处理，前导的0的处理，负数的处理。 class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" if x == 0: return 0 if x > 0: if x > 2**31-1: return 0 x = str(x) ans = \"\" mark = 1 for i in range(1,len(x)+1): if mark and x[len(x)-i] =='0': continue else: mark = 0 ans += x[len(x)-i] if int(ans) > 2**31-1: return 0 else: return int(ans) if x "},"8.html":{"url":"8.html","title":"8 String to Integer (atoi)","keywords":"","body":"8 String to Integer tagsstart Math String tagsstop 思路就是简单模拟，没有复杂的东西 class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" l = len(str) str = str.strip() if not str: return 0 flag = 1 if str[0] == '-': flag = -1 str = str[1:] elif str[0] == '+': flag = 1 str = str[1:] elif str[0] in ['0','1','2','3','4','5','6','7','8','9']: pass else: return 0 c = 0 for i in range(len(str)): if str[i] in ['0','1','2','3','4','5','6','7','8','9']: d = ord(str[i]) -ord('0') c = 10*c+d else: break c = c*flag if c >= 2**31-1: return 2**31-1 if c "},"9.html":{"url":"9.html","title":"9 Palindrome Number","keywords":"","body":"9 Palindrome Number tagsstart Math tagsstop Revert half of the number： Since we divided the number by 10, and multiplied the reversed number by 10, when the original number is less than the reversed number, it means we've processed half of the number digits. class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" if x revertVal): revertVal = revertVal * 10 + x % 10 x /= 10 return x == revertVal or x == revertVal/10 "},"10.html":{"url":"10.html","title":"10 Regular Expression Matching","keywords":"","body":"10 Regular Expression Matching tagsstart String Dynamic Programming Backtracking tagsstop Recursion: 确定基本情况，递归其他情况找到合适的matching DP: 建立DP递推表达式 class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" if not p: return not s first_match = bool(s) and p[0] in {s[0], '.'} if len(p) >= 2 and p[1] == '*': return self.isMatch(s,p[2:]) or (first_match and self.isMatch(s[1:],p)) else: return first_match and self.isMatch(s[1:], p[1:]) "},"11.html":{"url":"11.html","title":"11 Container With Most Water","keywords":"","body":"11 Container With Most Water tagsstart Array Two Pointers tagsstop 思路：使用前后两个指针, two pointer, 每次移动指向shorter one的指针，同时记录最大值 class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" s,e = 0, len(height) - 1 areaSize = 0 while s areaSize: areaSize = curSize if height[s] "},"12.html":{"url":"12.html","title":"12 Integer to Roman","keywords":"","body":"12 Integer to Roman tagsstart Math String tagsstop 纯模拟 class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\" d = { 1:\"I\", 4:\"IV\", 5:\"V\", 9:\"IX\", 10:\"X\", 40:\"XL\", 50:\"L\", 90:\"XC\", 100:\"C\", 400:\"CD\", 500:\"D\", 900:\"CM\", 1000:\"M\" } ans = \"\" while num: for i in [1000,900,500,400,100,90,50,40,10,9,5,4,1]: if i "},"13.html":{"url":"13.html","title":"13 Roman to Integer","keywords":"","body":"13 Roman to Integer tagsstart Math String tagsstop 纯模拟 class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" d = { \"I\":1, \"IV\":4, \"V\":5, \"IX\":9, \"X\":10, \"XL\":40, \"L\":50, \"XC\":90, \"C\":100, \"CD\":400, \"D\":500, \"CM\":900, \"M\":1000 } ans = 0 l = 0 while l "},"14.html":{"url":"14.html","title":"14 Longest Common Prefix","keywords":"","body":"14 Longest Common Prefix tagsstart String tagsstop 两种思路： 第一种 vertical match, 第二种是 horizontal match class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if len(strs) == 0: return \"\" for i in range(len(strs[0])): c = strs[0][i] for j in range(1, len(strs)): if i == len(strs[j]) or strs[j][i] != c: return strs[0][:i] return strs[0] "},"15.html":{"url":"15.html","title":"15 3Sum","keywords":"","body":"15 Three Sum tagsstart Array Two Pointers tagsstop 思路: 最外层套一个循环，里面是Two Sum， 排序之后使用two pointer 来解，排序之后还有一个好处，就是在枚举和移动指针的时候，相等的值可以跳过，这样可以直接去重。 class Solution: def threeSum(self, nums): nums.sort() results = [] length = len(nums) for i in range(0, length - 2): if i and nums[i] == nums[i - 1]: continue self.find_two_sum(nums, i + 1, length - 1, -nums[i], results) return results def find_two_sum(self, nums, left, right, target, results): while left target: right -= 1 else: left += 1 "},"16.html":{"url":"16.html","title":"16 3Sum Closest","keywords":"","body":"16 3 Sum Closest tagsstart Array Two Pointers tagsstop 使用defaultdict 建立一个保存closest值的一个字典（相当于哈希表， 每次使用这个hash表进行更新操作 from collections import defaultdict class Solution: def threeSumClosest(self, nums: 'List[int]', target: 'int') -> 'int': \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" length = len(nums) resultList = [] d = defaultdict(int) nums.sort() for i in range(0,length-2): j = i + 1 k = length - 1 while (j "},"17.html":{"url":"17.html","title":"17 Letter Combinations of a Phone Number","keywords":"","body":"17 Letter Combinations of a Phone number tagsstart String Backtracking tagsstop class Solution(object): def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\" ans = [] d = { 2:\"abc\", 3:\"def\", 4:\"ghi\", 5:\"jkl\", 6:\"mno\", 7:\"pqrs\", 8:\"tuv\", 9:\"wxyz\" } for i in range(len(digits)): p = d[ord(digits[i])-ord(\"0\")] if len(ans) == 0: for j in p: ans.append(j) else: ans_new = [] for j in p: for k in ans: ans_new.append(k+j) ans = ans_new #print ans return ans "},"18.html":{"url":"18.html","title":"18 4Sum","keywords":"","body":"18 4 Sum tagsstart Array Hash Table Two Pointers tagsstop 注意里面去重的判断： if i and nums[i] == nums[i-1], if j != i + 1 and nums[j] == nums[j - 1], while left class Solution(object): def fourSum(self, nums, target): nums.sort() res = [] length = len(nums) for i in range(0, length - 3): if i and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j != i + 1 and nums[j] == nums[j - 1]: continue sum = target - nums[i] - nums[j] left, right = j + 1, length - 1 while left sum: right -= 1 else: left += 1 return res "},"19.html":{"url":"19.html","title":"19 Remove Nth Node From End of List","keywords":"","body":"19 Remove Nth Node from End of the List tagsstart Linked List Two Pointers tagsstop 使用快慢指针的方法，维护两个指针，指针的间距是N， 当快指针为空的时候，慢指针指向了需要删除的节点。 两个技巧，使用dummy头在全部的元素之前，另一个技巧将前面的过程合并成一个循环来写。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" dummy = ListNode(0) dummy.next = head fast, slow = dummy, dummy while fast.next: if n Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode slow = dummyHead; ListNode fast = dummyHead; while(fast.next != null){ if (n "},"20.html":{"url":"20.html","title":"20 Valid Parentheses","keywords":"","body":"20 Valid Parentheses tagsstart String Stack tagsstop \u001d使用栈进行括号匹配的判断，如果需要的多，可以使用hash表预存储 class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" d = { '(' : ')', '{' : '}', '[' : ']' } length = len(s) st = [] for i in range(length): if s[i] in ['(', '{', '[']: st.append(s[i]) else: if len(st) == 0 or d[st[-1]] != s[i]: return False else: st.pop() if st == []: return True else: return False "},"21.html":{"url":"21.html","title":"21 Merge Two Sorted Lists","keywords":"","body":"21 Merge Two Sorted Arrays tagsstart Linked List tagsstop 两种思路 一种是recursion，每次处理两个数组的头，然后循环调用自己，处理后面的部分。空间复杂度 O(n+m) 时间复杂度 O(n+m) 第二种是Iteration, 时间复杂度O(n+m), 空间复杂度O(1) Python ```python Definition for singly-linked list. class ListNode(object): def init(self, x): self.val = x self.next = None class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" if l1 is None: return l2 elif l2 is None: return l1 elif l1.val ```python class Solution(object): def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" prehead = ListNode(-1) prev = prehead while l1 and l2: if l1.val Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1 == null){ return l2; } if(l2 == null){ return l1; } if(l1.val /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode p = dummy; while (l1 != null||l2 != null) { if (l1 == null){ p.next = l2; return dummy.next; } if (l2 == null){ p.next = l1; return dummy.next; } if(l1.val "},"22.html":{"url":"22.html","title":"22 Generate Parentheses","keywords":"","body":"22 Generate Parentheses tagsstart String Backtracking tagsstop 使用helper 函数帮助进行迭代，类似于二叉树遍历中后序遍历，先处理左右子树，最后处理根节点。helper 函数的三个参数，剩余的open, 剩余的close，以及当前的字串。 class Solution(object): def generateParenthesis(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" ## def helper(left, right, current): if left == 0 and right == 0: return current if left > right: return current if current == []: return helper(left-1, right, [\"(\"]) ans = [] for i in current: if left > 0: ans.extend(helper(left-1, right, [ i+\"(\" ])) if right > 0 and left "},"23.html":{"url":"23.html","title":"23 Merge k Sorted Lists","keywords":"","body":"23 Merge K sorted Lists tagsstart Linked List Heap Divide and Conquer tagsstop 最外层一个循环, 每次选取K个lists里面最小的元素，加到链表之中。 注意需要对于输入进行验证，判断输入为空的情况。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def mergeKLists(self, lists): \"\"\" :type lists: List[ListNode] :rtype: ListNode \"\"\" preHead = ListNode(-1) curNode = preHead length = len(lists) new_list = [] if length == 0: return None for i in lists: if i is not None: new_list.append(i) while new_list: minVal, index = None, -1 length = len(new_list) for l in range(length): if minVal is None or minVal > new_list[l].val: minVal = new_list[l].val index = l curNode.next = ListNode(minVal) curNode = curNode.next new_list[index] = new_list[index].next if new_list[index] is None: del new_list[index] return preHead.next Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue heap = new PriorityQueue(new Comparator(){ public int compare(ListNode o1, ListNode o2){ return o1.val - o2.val; } }); for (ListNode node:lists){ if(node != null){ heap.offer(node); } } ListNode pre = new ListNode(-1); ListNode temp = pre; while(!heap.isEmpty()){ ListNode curr = heap.poll(); temp.next = new ListNode(curr.val); if(curr.next != null){ heap.offer(curr.next); } temp = temp.next; } return pre.next; } } 编程知识点总结 Java 实现优先队列（堆）：实际上是一个堆，队列的头是按照指定排序方法中的最小元素（数组）。 队列默认情况使用数组实现，但数组的大小可以动态增加，容量无限。 队列中不允许使用null元素 使用Comparator进行构建时，新的类需要实现Comparator接口，接口要求定义compare函数。 PriorityQueue heap = new PriorityQueue(new Comparator(){ public int compare(ListNode o1, ListNode o2){ return o1.val - o2.val; } }); 常见方法 添加方法：offer(E e), add(E e) 时间复杂度O(log(n)) 删除方法：remove(Object o), poll(E e) 获取头元素：peek() 获取大小：size() 转成数组：toArray() 是否包含：contains(Object o) 全部清除：clear() 通用方法：iterator(),comparator() "},"24.html":{"url":"24.html","title":"24 Swap Nodes in Pairs","keywords":"","body":"24 Swap Nodes in Pairs tagsstart Linked List tagsstop 交换链表相邻节点值。涉及到这种交换节点的问题，可以 先修改两个前驱节点的next指针，再修改当前节点的next指针。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head is None: return head dummy = ListNode(0) dummy.next = head prev, node1 = dummy, head while node1 and node1.next: # current node => node # current second node => node.next prev.next = node1.next node1.next = node1.next.next node1.next.next = node1 prev = node1 node1 = node1.next return dummy.next Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode swapPairs(ListNode head) { if(head == null){ return null; } ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode prev = dummyHead; ListNode node1 = head; ListNode node2 = null; while( node1 != null && node1.next != null){ node2 = node1.next; //modify two previous prev.next = node2; node1.next = node2.next; //modify two nodes' relationship node2.next = node1; // go on prev = node1; node1 = node1.next; } return dummyHead.next; } } "},"25.html":{"url":"25.html","title":"25 Reverse Nodes in k-Group","keywords":"","body":"25 Reverse Nodes in k-group tagsstart Linked List tagsstop 编写链表反转的辅助函数，同时使用dummy作为哑头结点，使用prehead，cur_head来保存前一个部分的反转链表以及当前反转链表。 Python # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reverseList(self, head): prev, curr = None, head while curr: nexttemp = curr.next curr.next = prev prev = curr curr = nexttemp return prev def reverseKGroup(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" dummy = ListNode(0) dummy.next = head cur = head prev_head = dummy cur_head = head i = 0 while cur: i += 1 if i == k: temp = cur.next cur.next = None prev_head.next = self.reverseList(cur_head) prev_head = cur_head i = 0 cur = temp cur_head = temp else: cur = cur.next if cur_head: prev_head.next = cur_head return dummy.next ### 返回哑链表头结点的next指针，这样可以方便处理头结点为空的情况 Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { private ListNode reverseList(ListNode head){ ListNode prev = null; ListNode curr = head; ListNode next = null; while(curr != null){ next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; } public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = head; ListNode prev_head = dummy; ListNode cur_head = head; int i = 0; while (cur != null){ i += 1; if (i == k){ ListNode temp = cur.next; cur.next = null; prev_head.next = this.reverseList(cur_head); //go on prev_head = cur_head; i = 0; cur = temp; cur_head = temp; } else{ cur = cur.next; } } if(cur_head != null){ prev_head.next = cur_head; } return dummy.next; } } "},"26.html":{"url":"26.html","title":"26 Remove Duplicates from Sorted Array","keywords":"","body":"26 Remove Duplicates From Sorted Arrays tagsstart Array Two Pointers tagsstop 使用双指针，用一个指针i保存当前没有重复的数组位置下标，另一个j用来进行循环，循环过程中，如果相同则跳过，否则将值赋值到下一个i的位置。注意输入数据的处理。 class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" l = len(nums) if l == 0: return 0 ans = 0 for i in range(1,l): if nums[ans] == nums[i]: continue else: ans+=1 nums[ans] = nums[i] return ans+1 "},"27.html":{"url":"27.html","title":"27 Remove Element","keywords":"","body":"27 Remove Element tagsstart Array Two Pointers tagsstop 使用单指针，循环判断当前数组元素是否和指定value相等，如果相等，则弹出当前元素。 class Solution: def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" point = 0 index = 0 ans = 0 for i in range(len(nums)): point = nums[index] if point == val: nums.pop(index) nums.append(val) else: index += 1 ans += 1 return ans "},"28.html":{"url":"28.html","title":"28 Implement strStr()","keywords":"","body":"28 Implement strstr() tagsstart Two Pointers String tagsstop 题目不难，但是需要注意的地方很多。首先判断如果两个字符串长度不满足关系，可以直接返回。 不然进行双重循环，每次循环首先判断长度，然后进行匹配，如果都匹配不了，返回-1 class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" target_length = len(needle) pattern_length = len(haystack) if pattern_length pattern_length: return -1 f = True for j in range(start_position, end_position): if haystack[j] != needle[j-start_position]: f = False break if f is True: return i return -1Copy class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" for i in range(len(haystack) + 1): for j in range(len(needle) + 1): if j == len(needle): return i if i + j == len(haystack): return -1 if needle[j]!=haystack[i + j]: break "},"29.html":{"url":"29.html","title":"29 Divide Two Integers","keywords":"","body":"29 Divide Two Integers tagsstart Math Binary Search tagsstop 看到题目之后，想到了使用二分法进行处理，但是如果只是单纯用减法的话，得到解的速度太慢了~，采用位运算的方法，对于divisor进行移位操作，这样来加快二分的处理过程~ Python class Solution(object): def divide(self, dividend, divisor): \"\"\" :type dividend: int :type divisor: int :rtype: int \"\"\" flag = (dividend = 0x7r: if flag and ans == 0x80000000: return -0x80000000 return 0x7fffffff return ans if not flag else -ans Java class Solution { public int divide(int dividend, int divisor) { if(divisor == 0) { return Integer.MAX_VALUE; } boolean isNeg = (dividend^divisor)>>>31 == 1; int res = 0; if(dividend == Integer.MIN_VALUE) { dividend += Math.abs(divisor); if(divisor == -1) { return Integer.MAX_VALUE; } res++; } if(divisor == Integer.MIN_VALUE) { return res; } dividend = Math.abs(dividend); divisor = Math.abs(divisor); int digit = 0; while(divisor >1)) { divisor =0) { if(dividend>=divisor) { res += 1>= 1; digit--; } return isNeg?-res:res; } } "},"30.html":{"url":"30.html","title":"30 Substring with Concatenation of All Words","keywords":"","body":"30 Substring with Concatenation of All Words tagsstart Hash Table Two Pointers String tagsstop 两种解法，第一种解法采用模拟的方法，将字符串做分割后，判断得到的字符串是否满足要求。 第二种解法: 使用sliding window，控制start, end指针，截断相关的字符串， 如果满足条件，那么扩展end，如果出现不对的情况，在进行start指针调整，使用哈希表记录指针需要移动的位置，方便进行后面的操作。 注意问题：words里面存在重复的单词，满足条件的字符串的位置不一定是整数个word之后起始的位置。 class Solution(object): def findSubstring(self, s, words): \"\"\" :type s: str :type words: List[str] :rtype: List[int] \"\"\" if words == []: return [] ans = [] word_count = len(words) word_length = len(words[0]) length = word_count * word_length i = 0 temp = {} for word in words: if word not in temp: temp[word] = 1 else: temp[word] += 1 while i wordDict[tmp]: t = s[left:left+wordLen] left += wordLen tmpDict[t] -= 1 if tmpDict[t] "},"31.html":{"url":"31.html","title":"31 Next Permutation","keywords":"","body":"31 Next Permutation tagsstart Array tagsstop 计算下一个序列：首先对数组从右向左进行扫描，找到第一个不是递增的元素，将元素标记为p, 然后从p元素开始，向右扫描，找到比p大的最小元素，记为q， 交换p元素和q元素，然后对于p元素后续的元素进行反转，得到下一个排序。 class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\" if not nums or len(nums) == 1: return n = len(nums) for i in range(n-1, -1, -1): if nums[i-1] nums[i-1]: nums[j], nums[i-1] = nums[i-1], nums[j] nums[i:] = sorted(nums[i:]) break break "},"32.html":{"url":"32.html","title":"32 Longest Valid Parentheses","keywords":"","body":"32 Longest Valid Parentheses tagsstart String Dynamic Programming tagsstop 动态规划的方法： 使用一个dp数组，第i位存储以第i位为结尾的最长的匹配字符串长度。这样的话，很明显，只有以\")\"结尾，才有可能是匹配字符串的末尾，因此，我们将所有\"(\"对应的位置的dp值定义为0，同时只更新\")\"处的dp数值。 动态规划的递归计算方法： 如果当前是\")\", 并且上一个元素是”(“，那么dp[i] = dp[i-2]+2 如果当前是\")\", 并且上一个元素是”)“，如果s[i-dp[i-1]-1] == '(' 那么dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2 class Solution(object): def longestValidParentheses(self, s): \"\"\" :type s: str :rtype: int \"\"\" if s == \"\": return 0 length = len(s) dp = [0 for i in range(length)] for i in range(length): if s[i] == \"(\": dp[i] = 0 if length >= 2: dp[1] = 2 if s[:2] == \"()\" else 0 for i in range(2, length): if s[i] == \"(\": dp[i] = 0 else: if s[i-1] == \"(\": dp[i] = dp[i-2] + 2 if s[i-1] == \")\" and i-dp[i-1]-1 >=0 and s[i-dp[i-1]-1] == \"(\": dp[i] = dp[i-1] + dp[i-dp[i-1] - 2] + 2 return max(dp) "},"33.html":{"url":"33.html","title":"33 Search in Rotated Sorted Array","keywords":"","body":"33 Search in Rotated Sorted Arrays tagsstart Array Binary Search tagsstop 两遍binary search 注意写搜索的时候，边界判断条件。还有编写二分搜索的时候，需要多注意边界溢出的问题。二分的边界按照固定的方法来写。 二分搜素需要注意，区间开闭的问题。 Python class Solution(object): def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" def find_rotate_index(left, right): if nums[left] nums[pivot + 1]: return pivot + 1 else: if nums[pivot] Java class Solution { public int subsearch(int[] nums, int left, int right, int target){ while(left nums[pivot + 1]) return pivot + 1; else { if(nums[pivot] "},"34.html":{"url":"34.html","title":"34 Find First and Last Position of Element in Sorted Array","keywords":"","body":"34 Find First and Last Position of Element in a Sorted Array tagsstart Array Binary Search tagsstop 二分查找 Python class Solution(object): def searchRange(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" l, r = 0, len(nums) - 1 while l target: r = mid - 1 if nums[mid] == target: s, e = mid, mid while(s - 1 >= 0 and nums[s - 1] == target): s = s - 1 while(e + 1 Java class Solution { public int[] searchRange(int[] nums, int target) { int[] range = new int[2]; int left = 0; int right = nums.length; if (nums.length == 0) return new int[]{-1, -1}; while(left = nums.length || nums[right] != target) return new int[]{-1, -1}; range[0] = right; right = nums.length; while(left "},"35.html":{"url":"35.html","title":"35 Search Insert Position","keywords":"","body":"35 Search Insert Position tagsstart Array Binary Search tagsstop 二分查找， 注意r指针指向的一直都是符合条件的最右边界 Python class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" l, r = 0, len(nums) while l Java class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.length; while(left "},"36.html":{"url":"36.html","title":"36 Valid Sudoku","keywords":"","body":"36 Valid Sudoku tagsstart Hash Table tagsstop 使用三个dict保存sudoku里面相关信息，按照规则进行验证。 from collections import Counter class Solution(object): def isValidSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: bool \"\"\" rows = [{} for i in range(9)] columns = [{} for i in range(9)] boxes = [{} for i in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num != '.': num = int(num) box_index = (i//3) * 3 + j//3 rows[i][num] = rows[i].get(num, 0) + 1 columns[j][num] = columns[j].get(num, 0) + 1 boxes[box_index][num] = boxes[box_index].get(num, 0) + 1 if rows[i][num] > 1 or columns[j][num] > 1 or boxes[box_index][num] > 1: return False return True "},"37.html":{"url":"37.html","title":"37 Sudoku Solver","keywords":"","body":"37 Sudoku Solver tagsstart Hash Table Backtracking tagsstop 使用回溯法对于问题进行解决。 回溯法的思路就是，选择一个进行处理，处理了之后，抹除处理效果，进行后续操作。 class Solution(object): def solveSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. \"\"\" self.board = board self.solve() def findUnassigned(self): for row in range(9): for col in range(9): if self.board[row][col] == '.': return row, col return -1,-1 def isValid(self,val,x,y): if self.checkRow(val,x,y) and self.checkCol(val,x,y) and self.checkBox(val,x,y): return True return False def checkCol(self,val,x,y): for col in range(9): if self.board[x][col] == chr(ord('0')+val): return False return True def checkRow(self,val,x,y): for row in range(9): if self.board[row][y] == chr(ord('0')+val): return False return True def checkBox(self,val,x,y): row_base = x-x%3 col_base = y-y%3 for row in range(3): for col in range(3): if self.board[row_base+row][col_base+col] == chr(ord('0')+val): return False return True def solve(self): x,y = self.findUnassigned() if [x,y] == [-1,-1]: return True for val in range(1,10): if self.isValid(val,x,y): self.board[x][y] = chr(ord('0')+val) if self.solve(): return True self.board[x][y] = '.' return False "},"38.html":{"url":"38.html","title":"38 Count and Say","keywords":"","body":"38 Count and Say tagsstart String tagsstop class Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" def countandsay(n): \"\"\" :type n: str :rtype: str \"\"\" p = 0 ans = \"\" while p "},"39.html":{"url":"39.html","title":"39 Combination Sum","keywords":"","body":"39 Combination Sum tagsstart Array Backtracking tagsstop candidates 数组中没有重复的数字，但是combination中各个数字可以使用多次, 注意为了避免得到的集合中出现重复的组合，使用backtracking 进行解决 class Solution(object): def combinationSum(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\" ans = [] def dfs(index, cur, cur_set): if cur == target: ans.append(cur_set) return if cur > target: return length = len(candidates) for i in range(index, length): new_set = cur_set[:] new_set.append(candidates[i]) dfs(i, cur + candidates[i], new_set) dfs(0, 0, []) return ans "},"40.html":{"url":"40.html","title":"40 Combination Sum II","keywords":"","body":"40 Combination Sum II tagsstart Array Backtracking tagsstop candidates中可能有重复的，且每个元素只能访问一次。ans中不能存在重复的。 class Solution(object): def combinationSum2(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\" ans = [] def dfs(vis, index, cur, cur_set): if cur == target: ans.append(cur_set) return if cur > target: return length = len(candidates) for i in range(index, length): if i and candidates[i-1] == candidates[i] and vis[i-1] is False: continue if vis[i] is False: vis[i] = True new_cur_set = cur_set[::] new_cur_set.append(candidates[i]) dfs(vis, i, cur + candidates[i], new_cur_set) vis[i] = False candidates.sort() dfs([False for i in range(len(candidates))],0, 0, []) return ans "},"41.html":{"url":"41.html","title":"41 First Missing Positive","keywords":"","body":"41 First Missing Positive Number tagsstart Array tagsstop 思路很奇妙，首先进行初始条件的处理，首先判断1是否在数组中，然后将数组中小于等于0的元素和大于数组长度的元素换成1。之后处理时候，按照num[i] 的数值对对应下标做反转符号操作，这样可以在in-place的空间通过值得符号记录是否存在等。 class Solution(object): def firstMissingPositive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" ans = 1 if ans not in nums: return ans if nums == [1]: return 2 length = len(nums) for i in range(length): if nums[i] length: nums[i] = 1 for i in range(length): a = abs(nums[i]) if a == length: nums[0] = -abs(nums[0]) else: nums[a] = -abs(nums[a]) for i in range(1, length): if nums[i] > 0: return i if nums[0] > 0: return length return length + 1 "},"42.html":{"url":"42.html","title":"42 Trapping Rain Water","keywords":"","body":"42 Trapping Rain Water tagsstart Array Two Pointers Stack tagsstop 两种思路：第一种 brute force : 主要是记录两侧积水的最大值的最小值减去当前的高度得到数值。=> 超时 第二种思路是将上述过程中的一遍一遍扫描的结果记录下来，这样可以减少之后的扫描次数。 class Solution(object): def trap(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" left, right = 0, len(height) - 1 ans = 0 for i in range(1, len(height) - 1): max_left = 0 max_right = 0 for j in range(i, -1, -1): max_left = max(max_left, height[j]) for j in range(i, len(height)): max_right = max(max_right, height[j]) min_height = min(max_left, max_right) if min_height - height[i]: ans += min_height - height[i] return ans class Solution(object): def trap(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" if height == []: return 0 pre = [] after = [] length = len(height) maxval = height[0] maxval_after = height[-1] for i in range(length): if height[i] "},"50.html":{"url":"50.html","title":"50 Pow(x, n)","keywords":"","body":"50 Pow(x,n) tagsstart Math Binary Search tagsstop 使用递归的思路，每次折半，使用平方的方法。 class Solution(object): def myPow(self, x, n): \"\"\" :type x: float :type n: int :rtype: float \"\"\" if x==0 or x==1 or n==1: return x if x==-1: if n%2 ==0: return 1 else: return -1 if n==0: return 1 if n "},"61.html":{"url":"61.html","title":"61 Rotate List","keywords":"","body":"61 Rotate List tagsstart Linked List Two Pointers tagsstop 按照题目思路，注意首先需要取余，保证K的大小合适 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def rotateRight(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" if not head: return head l = 1 p = head while p.next: p = p.next l += 1 k = k % l if k == 0: return head k = l - 1 - k % l pp = head while k > 0: pp = pp.next k -= 1 newHead = pp.next pp.next = None p.next = head return newHead Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null){ return head; } int l = 1; ListNode p = head; while(p.next != null){ l += 1; p = p.next; } ListNode cur = head; k = k % l; if (k == 0){ return head; } k = l - 1 - k % l; while(k > 0){ cur = cur.next; k -= 1; } ListNode newHead = cur.next; cur.next = null; p.next = head; return newHead; } } "},"62.html":{"url":"62.html","title":"62 Unique Paths","keywords":"","body":"62 Unique Paths tagsstart Array Dynamic Programming tagsstop 最基本二维动态规划，使用二维数组记录能到达的次数。 class Solution(object): def uniquePaths(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\" dp = [ [0 for j in range(m)] for i in range(n)] dp[0][0] = 1 for i in range(n): dp[i][0] = 1 for j in range(m): dp[0][j] = 1 for i in range(1,n): for j in range(1,m): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1] "},"63.html":{"url":"63.html","title":"63 Unique Paths II","keywords":"","body":"63 Unique Paths II tagsstart Array Dynamic Programming tagsstop 稍微加了一个obstacle, 使用类似的动态规划，也可以得到解。 class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): \"\"\" :type obstacleGrid: List[List[int]] :rtype: int \"\"\" row = len(obstacleGrid) column = len(obstacleGrid[0]) if row == 0 or column == 0: return 0 dp = [[0 for j in range(column)]for i in range(row)] if obstacleGrid[0][0] == 1: return 0 else: dp[0][0] = 1 ## dp initialization for i in range(1, row): if obstacleGrid[i][0] == 0: dp[i][0] = dp[i-1][0] else: dp[i][0] = 0 for j in range(1,column): if obstacleGrid[0][j] == 0: dp[0][j] = dp[0][j-1] else: dp[0][j] = 0 for i in range(1, row): for j in range(1, column): if obstacleGrid[i][j] == 1: dp[i][j] = 0 continue else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[row-1][column-1] "},"64.html":{"url":"64.html","title":"64 Minimum Path Sum","keywords":"","body":"64 Minimum Path Sum tagsstart Array Dynamic Programming tagsstop 基本动态规划，类似于数字三角形。 class Solution(object): def minPathSum(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" if len(grid) == 0 or len(grid[0]) == 0: return 0 row, column = len(grid), len(grid[0]) for i in range(row - 2, -1, -1): grid[i][column - 1] += grid[i + 1][column - 1] for j in range(column - 2, -1, -1): grid[row - 1][j] += grid[row - 1][j + 1] for i in range(row - 2, -1, -1): for j in range(column - 2, -1, -1): grid[i][j] += min(grid[i][j+1], grid[i+1][j]) return grid[0][0] "},"69.html":{"url":"69.html","title":"69 Sqrt","keywords":"","body":"69 Sqrt(x) tagsstart Math Binary Search tagsstop Python class Solution(object): def mySqrt(self, x): \"\"\" :type x: int :rtype: int \"\"\" left, right = 0, x while left Java class Solution { public int mySqrt(int x) { int left = 0; int right = x; if( x == 0 || x == 1) return x; while (left "},"74.html":{"url":"74.html","title":"74 Search a 2D Matrix","keywords":"","body":"74 Search a 2D Matrix tagsstart Array Binary Search tagsstop Java 将原先二维矩阵转换成一维的响亮进行处理，实现二分搜索。 class Solution { public boolean searchMatrix(int[][] matrix, int target) { if(matrix.length == 0) return false; int rowCount = matrix.length; int colCount = matrix[0].length; int left = 0; int right = rowCount * colCount - 1; while(left 0 && matrix[left / colCount][left % colCount] == target) return true; if(colCount > 0 && matrix[right / colCount][right % colCount] == target) return true; return false; } } "},"77.html":{"url":"77.html","title":"77 Combinations","keywords":"","body":"77 Combinations tagsstart Backtracking tagsstop backtracking 回溯法，定义终止返回条件，类似于遍历树的孩子, 注意可以增加一个判断，减少不必要的循环。 class Solution(object): def __init__(self): self.res = [] def helper(self, current, choose_from, remain): if remain == 0: self.res.append(current) elif remain > len(choose_from): return else: for i in range(len(choose_from)): temp = current[:] temp.append(choose_from[i]) temp_choose_from = choose_from[i+1:] self.helper(temp,temp_choose_from, remain - 1) def combine(self, n, k): \"\"\" :type n: int :type k: int :rtype: List[List[int]] \"\"\" self.helper([],[i for i in range(1,n+1)], k) return self.res "},"82.html":{"url":"82.html","title":"82 Remove Duplicates from Sorted List II","keywords":"","body":"82 Remove Duplicates from Sorted List II tagsstart Linked List tagsstop 循环过一遍， 如果和上一个元素相同，或者和下一个元素相同，那么忽略它，不同，则添加到新的链表里面。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" q, pre, p = None, None, head newhead = None while p: if (p.next and p.val == p.next.val) or (pre and pre.val == p.val): pass else: if q is None: q = ListNode(p.val) newhead = q else: q.next = ListNode(p.val) q = q.next pre = p p = p.next return newhead Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null){ return head; } ListNode fakeHead = new ListNode(-1); fakeHead.next = head; ListNode prev = fakeHead, curr = head; while(curr != null){ while(curr.next != null && curr.val == curr.next.val){ curr = curr.next; } if(prev.next == curr){ prev = prev.next; } else{ prev.next = curr.next; } curr = curr.next; } return fakeHead.next; } } "},"83.html":{"url":"83.html","title":"83 Remove Duplicates from Sorted List","keywords":"","body":"83 Remove Duplicates from Sorted List tagsstart Linked List tagsstop 循环过一遍， 如果和上一个元素相同，那么忽略它，不同，则添加到新的链表里面。 可以多使用一个循环减少多余的空间开销。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head is None: return None new_head = ListNode(head.val) cur = new_head p = head.next while p: if p.val != cur.val: cur.next = ListNode(p.val) cur = cur.next p = p.next return new_head Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode ret = new ListNode(-1); ret.next = head; while(head != null){ while(head.next != null && head.next.val == head.val){ head.next = head.next.next; } head = head.next; } return ret.next; } } "},"86.html":{"url":"86.html","title":"86 Partition List","keywords":"","body":"86 Partition List tagsstart Linked List Two Pointers tagsstop 循环过一遍，遇到超过的放在一个List里面，另外的放到另一个List里面。注意使用两个假节点的技巧。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def partition(self, head, x): \"\"\" :type head: ListNode :type x: int :rtype: ListNode \"\"\" aDummy = ListNode(-1) bDummy = ListNode(-1) aCur, bCur = aDummy, bDummy while(head): next = head.next head.next = None if head.val Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode partition(ListNode head, int x) { ListNode aDummy = new ListNode(-1); ListNode aPoint = aDummy; ListNode bDummy = new ListNode(-1); ListNode bPoint = bDummy; ListNode p = head; while(p != null){ if(p.val "},"92.html":{"url":"92.html","title":"92 Reverse Linked List II","keywords":"","body":"92 Reverse Linked List II tagsstart Linked List tagsstop 从m到n位，对于链表进行反转 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reverseBetween(self, head, m, n): \"\"\" :type head: ListNode :type m: int :type n: int :rtype: ListNode \"\"\" dummy = ListNode(-1) dummy.next = head pre = dummy for i in range(m-1): pre = pre.next cur = pre.next for i in range(m, n): t = cur.next cur.next = t.next t.next = pre.next pre.next = t return dummy.next Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { ListNode fakeHead = new ListNode(-1); fakeHead.next = head; ListNode prev = fakeHead; for(int i = 0; i "},"98.html":{"url":"98.html","title":"98 Valid Binary Tree","keywords":"","body":"98 Valid Binary Tree tagsstart Tree Depth-first Search tagsstop 二叉树遍历，回溯法，循环判断根节点和子节点。 class Solution(object): def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" def isValid(root,min,max): if root is None: return True if root.valmin: return isValid(root.left,min,root.val) and isValid(root.right,root.val,max) else: return False return isValid(root,-float('inf'), float('inf')) "},"109.html":{"url":"109.html","title":"109 Convert Sorted List to Binary Search Tree","keywords":"","body":"109 Convert Sorted List to Binary Search Tree tagsstart Linked List Depth-first Search tagsstop 每次取中点元素，新建成为新的二叉树。迭代 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def sortedListToBST(self, head): \"\"\" :type head: ListNode :rtype: TreeNode \"\"\" if head: pre = None slow, fast = head, head while fast and fast.next: pre = slow slow = slow.next fast = fast.next.next root = TreeNode(slow.val) if pre: pre.next = None root.left = self.sortedListToBST(head) root.right = self.sortedListToBST(slow.next) return root Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode sortedListToBST(ListNode head) { return this.toBSTRecursive(head, null); } private TreeNode toBSTRecursive(ListNode start,ListNode end){ if(start == end){ return null; } else{ ListNode mid = start; ListNode fast = start; while(fast != end && fast.next != end){ mid = mid.next; fast = fast.next.next; } TreeNode root = new TreeNode(mid.val); root.left = this.toBSTRecursive(start, mid); root.right = this.toBSTRecursive(mid.next, end); return root; } } } "},"138.html":{"url":"138.html","title":"138 Copy List with Random Pointer","keywords":"","body":"138 Copy List with Random Pointer tagsstart Linked List Hash Table tagsstop 使用哈希表进行存储 # Definition for singly-linked list with a random pointer. # class RandomListNode(object): # def __init__(self, x): # self.label = x # self.next = None # self.random = None class Solution(object): def __init__(self): # hash : using the visited nodes as key and the new keys as value self.hash = {} def copyRandomList(self, head): \"\"\" :type head: RandomListNode :rtype: RandomListNode \"\"\" if head is None: return None if head in self.hash: return self.hash[head] node = RandomListNode(head.label) self.hash[head] = node node.next = self.copyRandomList(head.next) node.random = self.copyRandomList(head.random) return node Java /* // Definition for a Node. class Node { public int val; public Node next; public Node random; public Node() {} public Node(int _val,Node _next,Node _random) { val = _val; next = _next; random = _random; } }; */ class Solution { public Node copyRandomList(Node head) { if(head == null){ return null; } Map map = new HashMap(); Node node = head; // the first loop copy only the value of the nodes while(node != null){ map.put(node, new Node(node.val)); node = node.next; } node = head; // the second copy: copy the next and the random pointers while(node != null){ map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; } return map.get(head); } } 知识点 Java Map的基本操作: 定义: Map map = new HashMap(); get(key),put(key, value) "},"141.html":{"url":"141.html","title":"141 Linked List Cycle","keywords":"","body":"141 Linked List Cycle tagsstart Linked List Two Pointers Hash Table tagsstop 方法一：使用哈希表存储每次经过的节点。 方法二：使用快慢指针的方法判断。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def __init__(self): self.hash = {} def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" while head and head not in self.hash: self.hash[head] = 1 head = head.next if head == None: return False else: return True Java public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast) { if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } "},"142.html":{"url":"142.html","title":"142 Linked List Cycle II","keywords":"","body":"142 Linked List Cycle II tagsstart Linked List Two Pointers tagsstop 返回循环开始的节点： 使用快慢指针。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" slow, fast = head, head while True: if fast is None: return None if fast.next and fast.next.next: slow = slow.next fast = fast.next.next else: return None if fast == slow: fast = head while fast != slow: fast = fast.next slow = slow.next return fast Java /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while(true){ if(fast == null){ return null; } if (fast.next != null && fast.next.next != null){ slow = slow.next; fast = fast.next.next; } else{ return null; } if (fast == slow){ fast = head; while(fast != slow){ fast = fast.next; slow = slow.next; } return fast; } } } } "},"143.html":{"url":"143.html","title":"143 Reorder List","keywords":"","body":"143 Reorder List tagsstart Linked List tagsstop 重新排列一个List Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reorderList(self, head): \"\"\" :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. \"\"\" if head is None: return None slow, fast = head, head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next # slow => middle node # 2nd. change the last part = > reverse linkedlist pre = slow cur = pre.next pre.next = None prev = None while cur: nxt = cur.next cur.next = prev prev = cur cur = nxt # 3rd: connect list =[10,60,20,50,30] prev = [40] p = head while p and prev: t = p.next p.next = prev prev_nex = prev.next prev.next = t prev = prev_nex p = t return head Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void reorderList(ListNode head) { if(head == null){ return; } ListNode fast = head, slow = head; while(fast.next != null && fast.next.next != null){ slow = slow.next; fast = fast.next.next; } ListNode curr = slow.next; slow.next = null; ListNode prev = null; while(curr != null){ ListNode nxt = curr.next; curr.next = prev; prev = curr; curr = nxt; } ListNode p = head; while(p != null && prev != null){ ListNode t = p.next; p.next = prev; ListNode prev_nex = prev.next; prev.next = t; prev = prev_nex; p = t; } return; } } "},"146.html":{"url":"146.html","title":"146 LRU Cache","keywords":"","body":"146 LRU Cache 使用OrderedDict类实现， 使用 move_to___end 方法，对于LRU Cache进行模拟 class LRUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" self.capacity = capacity self.ordered_dict = collections.OrderedDict() def get(self, key): \"\"\" :type key: int :rtype: int \"\"\" if key not in self.ordered_dict: return -1 self.ordered_dict.move_to_end(key) return self.ordered_dict[key] def put(self, key, value): \"\"\" :type key: int :type value: int :rtype: None \"\"\" if key in self.ordered_dict: self.ordered_dict.move_to_end(key) self.ordered_dict[key] = value if len(self.ordered_dict) > self.capacity: self.ordered_dict.popitem(last = False # Your LRUCache object will be instantiated and called as such: # obj = LRUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value) "},"147.html":{"url":"147.html","title":"147 Insertion Sort List","keywords":"","body":"147 Insertion Sort List tagsstart Linked List Sort tagsstop 在链表中实现插入排序 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def insertionSortList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" dummyHead = ListNode(0) dummyHead.next = head p = head while p and p.next: if p.val Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode p = head; while(p != null && p.next != null){ if(p.val "},"148.html":{"url":"148.html","title":"148 Sort List","keywords":"","body":"148 Sort List tagsstart Linked List Sort tagsstop 对于链表进行排序，要求时间复杂度为O(nlogn)，考虑使用二分的方法进行排序。如何将链表分成两个部分？使用之前常用的快慢指针的方法。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def sortList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head: fast, slow = head, head pre = None while fast and fast.next: fast = fast.next.next pre = slow slow = slow.next if not pre: return head pre.next = None left = self.sortList(head) right = self.sortList(slow) p = dummy = ListNode(-1) while left and right: if left.val Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode sortList(ListNode head) { if (head != null){ ListNode fast = head, slow = head; ListNode pre = null; while(fast != null && fast.next != null){ fast = fast.next.next; pre = slow; slow = slow.next; } if(pre == null) return head; pre.next = null; ListNode left = this.sortList(head); ListNode right = this.sortList(slow); ListNode p = new ListNode(-1); ListNode dummy = p; while(left != null && right != null){ if(left.val "},"153.html":{"url":"153.html","title":"153 Find Minimum in Rotated Sorted Array","keywords":"","body":"153 Find Minimum in Rotated Sorted Array tagsstart Array Binary Search tagsstop 具体思路可以参照33题里面寻找rotate_index函数部分。 Java class Solution { public int find_rotate_index(int[] nums, int left, int right){ if(nums[left] nums[pivot + 1]) return pivot + 1; else { if(nums[pivot] "},"154.html":{"url":"154.html","title":"154 Find Minimum in Rotated Sorted Array II","keywords":"","body":"154 Find Minimum in Rotated Array II tagsstart Array Binary Search tagsstop Java class Solution { public int findMin(int[] nums) { if(nums.length == 0) return 0; int left = 0; int right = nums.length - 1; int res = nums[0]; while (left nums[mid]){ res = Math.min(res, nums[right]); right = mid; } else left ++; } res = Math.min(res, nums[left]); res = Math.min(res, nums[right]); return res; } } "},"160.html":{"url":"160.html","title":"160 Intersection of Two Linked List","keywords":"","body":"160 Intersection of Two Linked Lists tagsstart Linked List Hash Table Two Pointers tagsstop 寻找两个单链表连接起来的地方 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def __init__(self): self.hash = [] def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\" p = headA while p is not None: self.hash.append(p) p = p.next p = headB while p is not None: if p in self.hash: return p p = p.next return p Java 分别遍历两个链表，得到分别对应的长度。然后求长度的差值，把较长的那个链表向后移动这个差值的个数，然后一一比较即可。代码如下： /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public int getLength(ListNode head){ ListNode p = head; int cnt = 0; while(p != null){ cnt += 1; p = p.next; } return cnt; } public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; int lenA = this.getLength(headA), lenB = this.getLength(headB); if (lenA > lenB) { for (int i = 0; i 还有一种方法也非常巧妙，就是利用循环两个链表，使得两个指针相遇。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p = headA, q = headB; while(p != q){ p = (p != null) ? p.next : headB; q = (q != null) ? q.next : headA; } return p; } } "},"162.html":{"url":"162.html","title":"162 Find Peak Element","keywords":"","body":"162 Find Peak Element tagsstart Array Binary Search tagsstop Java 方法一： 一遍循环 class Solution { public int findPeakElement(int[] nums) { for(int i = 0; i nums[i + 1]) return i; } return nums.length - 1; } } Java 方法二： 改进版的二分查找 public class Solution { public int findPeakElement(int[] nums) { return search(nums, 0, nums.length - 1); } public int search(int[] nums, int l, int r) { if (l == r) return l; int mid = (l + r) / 2; if (nums[mid] > nums[mid + 1]) return search(nums, l, mid); return search(nums, mid + 1, r); } } "},"167.html":{"url":"167.html","title":"167 Two Sum II Input Array is sorted","keywords":"","body":"167 Two Sum II - Input array is sorted tagsstart Binary Search Two Pointers Array tagsstop Python class Solution(object): def twoSum(self, numbers, target): \"\"\" :type numbers: List[int] :type target: int :rtype: List[int] \"\"\" left,right = 0,len(numbers)-1 while left target: right -= 1 if numbers[left] + numbers[right] == target: return [left+1,right+1] "},"198.html":{"url":"198.html","title":"198 House Robber","keywords":"","body":"198 House Robber tagsstart Dynamic Programming tagsstop 最简单动态规划 class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len(nums) if length == 0: return 0 if length == 1: return nums[0] if length == 2: return nums[0] if nums[0] > nums[1] else nums[1] dp = [] dp.append(nums[0]) if nums[1] > nums[0]: dp.append(nums[1]) else: dp.append(nums[0]) for i in range(2,length): p = nums[i] if p + dp[i-2] > dp[i-1]: dp.append(p + dp[i-2]) else: dp.append(dp[i-1]) return dp[-1] "},"200.html":{"url":"200.html","title":"200 Numbers of Islands","keywords":"","body":"200 Numbers of Islands tagsstart Depth-first Search Breadth-first Search Union Find tagsstop 思路方法很多。 方法一：DFS， 深度优先搜索，可以使用栈或者使用回溯的方法实现。 方法二：BFS， 广度优先搜索，可以使用队列实现。 方法三：并查集，使用并查集将集合做合并 class Solution(object): def numIslands(self, grid): \"\"\" :type grid: List[List[str]] :rtype: int \"\"\" if grid is None or len(grid) == 0 or len(grid[0]) == 0: return 0 row, column, ans = len(grid), len(grid[0]), 0 vis = [[0 for j in range(column)]for i in range(row)] def dfs(x, y, vis): dx = [0, 0, -1, 1] dy = [1, -1, 0, 0] vis[x][y] = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx >= row or nx = column or ny class Solution: def numIslands(self, grid): \"\"\" :type grid: List[List[str]] :rtype: int \"\"\" if grid == []: return 0 nr, nc = len(grid),len(grid[0]) ans = 0 for i in range(nr): for j in range(nc): if(grid[i][j] =='1'): ans += 1 queue = [] queue.append((i,j)) grid[i][j] = '0' while(len(queue)!=0): (cur_x, cur_y) = queue.pop(0) dx = [0,0,1,-1] dy = [1,-1,0,0] for k in range(4): nx = cur_x + dx[k] ny = cur_y + dy[k] if nx = 0 and ny =0 and grid[nx][ny] == '1': queue.append((nx,ny)) grid[nx][ny] = '0'; return ans "},"203.html":{"url":"203.html","title":"203 Remove Linked List Elements","keywords":"","body":"203 Remove Linked List Elements tagsstart Linked List tagsstop 注意使用假节点的技巧 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def removeElements(self, head, val): \"\"\" :type head: ListNode :type val: int :rtype: ListNode \"\"\" p = head new_head = None cur = None while p: if p.val!=val: if new_head is None: new_head = ListNode(p.val) cur = new_head else: cur.next = ListNode(p.val) cur = cur.next p = p.next return new_head Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { ListNode p = head; ListNode fakeHead = new ListNode(-1); ListNode cur = fakeHead; while(p != null){ if(p.val != val){ cur.next = new ListNode(p.val); cur = cur.next; } p = p.next; } return fakeHead.next; } } "},"206.html":{"url":"206.html","title":"206 Reverse Linked List","keywords":"","body":"206 Reverse Linked List tagsstart Linked List tagsstop Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reverseList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" curr, prev = head, None while curr: nextt = curr.next curr.next = prev prev = curr curr = nextt return prev Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode curr = head; ListNode prev = null; while(curr != null){ ListNode temp = curr.next; curr.next = prev; prev = curr; curr = temp; } return prev; } } "},"208.html":{"url":"208.html","title":"208 Implement Trie(Prefix Tree)","keywords":"","body":"208 Implement Trie(Prefix Tree) tagsstart Design Trie tagsstop 使用dict 以及isWord 保存节点信息 Python class TrieNode(object): def __init__(self): self.children = dict() self.isWord = False class Trie(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.root = TrieNode() def insert(self, word): \"\"\" Inserts a word into the trie. :type word: str :rtype: None \"\"\" node = self.root for letter in word: child = node.children.get(letter) if child is None: child = TrieNode() node.children[letter] = child node = child node.isWord = True def search(self, word): \"\"\" Returns if the word is in the trie. :type word: str :rtype: bool \"\"\" node = self.root for letter in word: child = node.children.get(letter) if child is None: return False node = child return node.isWord def startsWith(self, prefix): \"\"\" Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool \"\"\" node = self.root for letter in prefix: child = node.children.get(letter) if child is None: return False node = child return True # Your Trie object will be instantiated and called as such: # obj = Trie() # obj.insert(word) # param_2 = obj.search(word) # param_3 = obj.startsWith(prefix) Java "},"211.html":{"url":"211.html","title":"211 Add and Search Word - Data Structure Design","keywords":"","body":"211 Add and Search Word - Data Structure Design tagsstart Backtracking Design Trie tagsstop class TrieNode(object): def __init__(self): self.children = dict() self.isWord = False class WordDictionary(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.root = TrieNode() def addWord(self, word): \"\"\" Adds a word into the data structure. :type word: str :rtype: None \"\"\" node = self.root for letter in word: child = node.children.get(letter) if child is None: node.children[letter] = TrieNode() node = node.children[letter] node.isWord = True def search(self, word): return self.find(self.root, word) def find(self, node, word): if word == '': return node.isWord if word[0] == '.': for x in node.children: if self.find(node.children[x], word[1:]): return True else: child = node.children.get(word[0]) if child: return self.find(child, word[1:]) return False # Your WordDictionary object will be instantiated and called as such: # obj = WordDictionary() # obj.addWord(word) # param_2 = obj.search(word) "},"215.html":{"url":"215.html","title":"215 Kth Largest Element in an Array","keywords":"","body":"215 Kth Largest Element in an Array tagsstart Divide and Conquer Heap tagsstop 使用heapq, 注意这个是小根堆， 每次出来的是最小的元素， 所以要两遍取负号~ import heapq class Solution(object): def findKthLargest(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: int \"\"\" nums = [-i for i in nums] heapq.heapify(nums) for i in range(k): ans = heapq.heappop(nums) return -ans "},"216.html":{"url":"216.html","title":"216 Combination Sum III","keywords":"","body":"216 Combination Sum III tagsstart Array Backtracking tagsstop 用K个1-9的数字组成N, 使用backtracking回溯方法来解。 class Solution(object): def __init__(self): self.ans = [] def combinationSum3(self, k, n): \"\"\" :type k: int :type n: int :rtype: List[List[int]] \"\"\" candidates = [i for i in range(10)] length = len(candidates) def dfs(vis, index, cur_sum, cur_num, cur): if cur_sum == n and cur_num == k: self.ans.append(cur) return if cur_sum > n: return for i in range(index, length): if vis[i] == False: vis[i] = True new_cur = cur[::] new_cur.append(candidates[i]) dfs(vis, i, cur_sum + candidates[i], cur_num + 1, new_cur) vis[i] = False dfs([False for i in range(10)], 1, 0, 0, []) return self.ans "},"234.html":{"url":"234.html","title":"234 Palindrome Linked List","keywords":"","body":"234 Palindrome Linked List tagsstart Linked List tagsstop 要求O(n) time and O(1) space 第一步： 找到中点 第二步： 翻转后半段 第三步：检查前半段和后半段是否相同 Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseList(self, head): curr, prev = head, None while curr: nextt = curr.next curr.next = prev prev = curr curr = nextt return prev def isPalindrome(self, head: 'ListNode') -> 'bool': fast, slow = head, head prev = None while fast and fast.next: fast = fast.next.next prev = slow slow = slow.next if prev: prev.next = None else: return True t = self.reverseList(slow) while(t and head): if head.val != t.val: return False head = head.next t = t.next return True "},"237.html":{"url":"237.html","title":"237 Delete Node in a Linked List","keywords":"","body":"237 Delete Node in a Linked List tagsstart Linked List tagsstop Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, node): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" val = node.next.val node.val = val node.next = node.next.next Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { int val = node.next.val; node.val = val; node.next = node.next.next; } } "},"328.html":{"url":"328.html","title":"328 Odd Even List","keywords":"","body":"328 Odd Even Linked List tagsstart Linked List tagsstop Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def oddEvenList(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" oddDummy = ListNode(-1) evenDummy = ListNode(-1) oddCur, evenCur = oddDummy, evenDummy cnt = 1 while(head): next = head.next head.next = None if cnt % 2 == 1: oddCur.next = head oddCur = oddCur.next else: evenCur.next = head evenCur = evenCur.next head = next cnt += 1 oddCur.next = evenDummy.next return oddDummy.next Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode oddEvenList(ListNode head) { int cnt = 1; ListNode oddDummy = new ListNode(-1); ListNode evenDummy = new ListNode(-1); ListNode oddP = oddDummy, evenP = evenDummy; while(head != null) { ListNode next = head.next; head.next = null; if(cnt % 2 == 0){ evenP.next = head; evenP = evenP.next; } else{ oddP.next = head; oddP = oddP.next; } cnt += 1; head = next; } oddP.next = evenDummy.next; return oddDummy.next; } } "},"369.html":{"url":"369.html","title":"369 Plus One Linked List","keywords":"","body":"369 Plus One Linked List tagsstart Linked List tagsstop 需要先翻转链表 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reverseList(self, head): prev, curr = None, head while curr: t = curr.next curr.next = prev prev = curr curr = t return prev def plusOne(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" rev = self.reverseList(head) curr = rev carry = 1 while curr: if carry == 0: break curr.val += carry carry = 0 if curr.val > 9: carry = 1 curr.val -= 10 curr = curr.next if carry == 1: t = ListNode(1) t.next = self.reverseList(rev) return t else: return self.reverseList(rev) Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head){ ListNode prev = null, curr = head; while(curr != null){ ListNode t = curr.next; curr.next = prev; prev = curr; curr = t; } return prev; } public ListNode plusOne(ListNode head) { ListNode rev = this.reverseList(head); ListNode cur = rev; int carry = 1; while(cur!= null){ cur.val += carry; carry = 0; if(cur.val > 9){ cur.val -= 10; carry = 1; } else{ break; } cur = cur.next; } if(carry == 1){ ListNode n = new ListNode(1); n.next = this.reverseList(rev); return n; } else{ return this.reverseList(rev); } } } "},"377.html":{"url":"377.html","title":"377 Combination Sum IV","keywords":"","body":"377 Combination Sum IV tagsstart Dynamic Programming tagsstop 这道题使用DP来做。 class Solution(object): def combinationSum4(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" dp = [0 for i in range(target + 1)] dp[0] = 1 for i in range(len(dp)): for num in nums: if i >= num: dp[i] += dp[i - num] return dp[target] "},"379.html":{"url":"379.html","title":"379 Design Phone Directory","keywords":"","body":"379 Design Phone Directory tagsstart Linked List Hash Table Queue Design tagsstop Python import Queue class PhoneDirectory(object): def __init__(self, maxNumbers): \"\"\" Initialize your data structure here @param maxNumbers - The maximum numbers that can be stored in the phone directory. :type maxNumbers: int \"\"\" self.max = maxNumbers - 1 self.set = set() self.queue = Queue.Queue(maxNumbers) for i in range(maxNumbers): self.queue.put(i) def get(self): \"\"\" Provide a number which is not assigned to anyone. @return - Return an available number. Return -1 if none is available. :rtype: int \"\"\" if self.queue.empty(): return -1 i = self.queue.get() self.set.add(i) return i def check(self, number): \"\"\" Check if a number is available or not. :type number: int :rtype: bool \"\"\" return (number Java class PhoneDirectory { int max; HashSet set; Queue queue; /** Initialize your data structure here @param maxNumbers - The maximum numbers that can be stored in the phone directory. */ public PhoneDirectory(int maxNumbers) { set = new HashSet(); queue = new LinkedList(); for(int i = 0; i 程序总结 Java 实现队列Queue 在java.util.Queue 中定义了Queue这个类接口，在java.util.LinkedList里面提供了对于这个接口的实现 offer(), add() : 添加元素，其中offer()在添加元素的时候，不会因为队列的长度报异常 poll(),remove(): 删除元素，都是删除第一个元素，但是使用poll()不会因为删除空队列报异常 peek(),element(): 返回头元素，在队列的头部查询元素。和remove()方法类似，使用peek()不会因为队列为空报异常， 只是返回null isEmpty()判断队列是否为空 Java 实现set 在java.util.Set中定义了Set接口，在java.util.HashSet里面提供了对于这个接口的实现。 contains() 判断元素是否存在 add()添加元素 remove() 删除元素 "},"414.html":{"url":"414.html","title":"414 Third Maximum Number","keywords":"","body":"414 Third Maximum Number tagsstart Array tagsstop 使用类似于215的解法，使用heapq包来进行解 import heapq class Solution(object): def thirdMax(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" nums = [-i for i in nums] heapq.heapify(nums) maxmum = nums[0] if len(nums) "},"426.html":{"url":"426.html","title":"426 Convert Binary Search Tree to Sorted Doubly Linked List","keywords":"","body":"426 Convert Binary Search Tree to Sorted Doubly Linked List tagsstart Linked List Divide and Conquer Tree tagsstop Python \"\"\" # Definition for a Node. class Node(object): def __init__(self, val, left, right): self.val = val self.left = left self.right = right \"\"\" class Solution(object): def helper(self, root): head, tail = root, root if root.left: left_head, left_tail = self.helper(root.left) left_tail.right = root root.left = left_tail head = left_head if root.right: right_head, right_tail = self.helper(root.right) right_head.left = root root.right = right_head tail = right_tail head.left = tail tail.right = head return head, tail def treeToDoublyList(self, root): \"\"\" :type root: Node :rtype: Node \"\"\" if not root: return root head, tail = self.helper(root) return head "},"430.html":{"url":"430.html","title":"430 Flatten a Multilevel Doubly Linked List","keywords":"","body":"430 Flatten a Multilevel Doubly Linked List tagsstart Linked List Depth-first Search tagsstop Python \"\"\" # Definition for a Node. class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child \"\"\" class Solution: def flatten(self, head: 'Node') -> 'Node': stack = [] cur = ans = Node(0, None, None, None) while head is not None or stack != []: if not head: head = stack.pop() if cur != ans: head.prev = cur cur.next = head cur = cur.next if head.child: if head.next: stack.append(head.next) prev_head = head head = head.child prev_head.child = None else: head = head.next return ans.next Java 题解：如果当前点cur 没有child, 直接跳到cur.next 进行下次计算。如果cur 有child, 目标是把cur.child这个level提到cur这个level上。至于cur.child 这个level上有没有点有child 先不管。 算法： cur.child 一直只按next找到tail； 这一节插在cur 和 cur.next之间； cur再跳到更新的cur.next上. Time Complexity: O(n) n是所有点的个数, 每个点只走过constant次数. Space: O(1) /* // Definition for a Node. class Node { public int val; public Node prev; public Node next; public Node child; public Node() {} public Node(int _val,Node _prev,Node _next,Node _child) { val = _val; prev = _prev; next = _next; child = _child; } }; */ class Solution { public Node flatten(Node head) { if(head == null) return head; Node cur = head; while(cur != null){ if (cur.child == null){ cur = cur.next; continue; } Node child = cur.child; Node childTail = child; while(childTail.next != null){ childTail = childTail.next; } cur.child = null; child.prev = cur; childTail.next = cur.next; if(cur.next != null){ cur.next.prev = childTail; } cur.next = child; cur = cur.next; } return head; } } "},"445.html":{"url":"445.html","title":"445 Add Two Numbers II","keywords":"","body":"445 Add Two Numbers II tagsstart Linked List tagsstop Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reverseList(self, head): prev, curr = None, head while curr: t = curr.next curr.next = prev prev = curr curr = t return prev def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" l1 = self.reverseList(l1) l2 = self.reverseList(l2) cur, carry = 0, 0 head = ListNode(0) curNode = head while l1 or l2: x = l1.val if l1 else 0 y = l2.val if l2 else 0 cur = x + y + carry carry = cur / 10 cur = cur % 10 curNode.next = ListNode(cur) curNode = curNode.next if l1: l1 = l1.next if l2: l2 = l2.next if carry: curNode.next = ListNode(carry) curNode = curNode.next return self.reverseList(head.next) "},"451.html":{"url":"451.html","title":"451 Sort Characters By Frequency","keywords":"","body":"451 Sort Characters By Frequency tagsstart Hash Table Heap tagsstop 方法一: 使用Python sort 函数 时间复杂度：O(nlogn) 方法二：使用heapq 最小堆 时间复杂度：O() class Solution(object): def frequencySort(self, s): \"\"\" :type s: str :rtype: str \"\"\" d = {} for char in s: if char in d: d[char] += 1 if char not in d: d[char] = 1 data = [] for key, value in d.items(): data.append((value, key)) data.sort(key = lambda item: item[0], reverse = True) ans = \"\" for i in range(len(data)): ans += data[i][1]*data[i][0] return ans import heapq class Solution(object): def frequencySort(self, s): \"\"\" :type s: str :rtype: str \"\"\" d = {} for char in s: if char in d: d[char] += 1 if char not in d: d[char] = 1 data = [] for key, value in d.items(): data.append((-value, key)) heapq.heapify(data) ans = \"\" while len(data): (value, key) = heapq.heappop(data) value = -value for i in range(value): ans += key return ans "},"526.html":{"url":"526.html","title":"526 Beautiful Arrangement","keywords":"","body":"526 Beautiful Arrangement tagsstart Backtracking tagsstop 使用回溯的思想，对于数组进行处理。 class Solution(object): def __init__(self): self.ans = 0 def helper(self, cnt, used, remain): if remain == 0: self.ans += 1 else: v = cnt + 1 for i in range(1, len(used)): if used[i] == False and (i % v == 0 or v % i == 0): used[i] = True self.helper( v, used, remain - 1) used[i] = False def countArrangement(self, N): \"\"\" :type N: int :rtype: int \"\"\" self.helper(0, [False for i in range(N+1)], N) return self.ans "},"683.html":{"url":"683.html","title":"683 K Empty Slots","keywords":"","body":"683 K Empty Slots tagsstart Ordered Map Sliding Window Binary Search Tree tagsstop 这道题目比较难写，有两种思路。 第一种思路：主要的思路是用哈希表或者用数组将原始数据做反映射，得到的数组，我们需要做的就是在数组中，找到长度为k+2的sliding windows, 其中间值小于两边的值的最大值。 第二种思路：使用BST, 使用bisect建立一个二分搜索树，可以使得时间复杂度，空间复杂度降低。 第三种思路：使用Buckets进行分段存储。 class Solution(object): def kEmptySlots(self, flowers, k): \"\"\" :type flowers: List[int] :type k: int :rtype: int \"\"\" hash = {} length = len(flowers) for day, position in enumerate(flowers): hash[position] = day + 1 left, right = 1, k+2 if right > length: return -1 ans = [] i = left + 1 while i max(hash[left], hash[right]): i += 1 continue else: if i == right: ans.append(max(hash[left], hash[right])) left = left + 1 right = right + 1 i = left + 1 if right > length: return min(ans) if ans else -1 else: left = i right = left + k + 1 i = left + 1 if right > length: return min(ans) if ans else -1 class Solution(object): def kEmptySlots(self, flowers, k): \"\"\" :type flowers: List[int] :type k: int :rtype: int \"\"\" l = len(flowers) if k = l: return -1 p = (l + k)/(k + 1) ## 将flowers分成p个槽 part = [[None,None] for i in range(p)] ##对于每个槽，记录每个槽的最低占位和最高占位所在的位置 0 => min 1 => max for i in range(l): num = (flowers[i] - 1)/(k + 1) if part[num][0] is None or flowers[i] part[num][1]: part[num][1] = flowers[i] if num class Solution(object): def kEmptySlots(self, flowers, k): \"\"\" :type flowers: List[int] :type k: int :rtype: int \"\"\" active = [] for day, flower in enumerate(flowers, 1): i = bisect.bisect(active, flower) for neighbor in active[i-(i>0): i+1]: if abs(neighbor - flower) - 1 == k: return day active.insert(i, flower) return -1 "},"686.html":{"url":"686.html","title":"686 Repeated String Match","keywords":"","body":"686 Repeated String Match tagsstart String tagsstop 找到两个字符串的周期，然后进行检查 class Solution(object): def repeatedStringMatch(self, A, B): \"\"\" :type A: str :type B: str :rtype: int \"\"\" q = (len(B) - 1) // len(A) + 1 for i in range(2): if B in A * (q+i): return q+i return -1 "},"703.html":{"url":"703.html","title":"703 Kth Largest Element in a Stream","keywords":"","body":"703 Kth Largest Element in a Stream tagsstart Heap tagsstop 使用Python里面自带的heapq库，维护一个大小为K的优先队列（最小堆) import heapq class KthLargest(object): def __init__(self, k, nums): \"\"\" :type k: int :type nums: List[int] \"\"\" self.data = nums self.k = k self.size = len(nums) heapq.heapify(self.data) while self.size > k: heapq.heappop(self.data) ## 将最小的弹出，最小堆的特点 self.size -= 1 def add(self, val): \"\"\" :type val: int :rtype: int \"\"\" if self.size self.data[0]: heapq.heappop(self.data) heapq.heappush(self.data, val) return self.data[0] ## 当前堆中最小的 "},"707.html":{"url":"707.html","title":"707 Design Linked List","keywords":"","body":"707 Design Linked List tagsstart Linked List Design tagsstop Python class MyNode(object): def __init__(self, val): self.val = val self.next = None class MyLinkedList(object): def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.head = None self.length = 0 def get(self, index): \"\"\" Get the value of the index-th node in the linked list. If the index is invalid, return -1. :type index: int :rtype: int \"\"\" if index = self.length: return -1 else: node = self.head for i in range(index): node = node.next return node.val def addAtHead(self, val): \"\"\" Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. :type val: int :rtype: None \"\"\" node = MyNode(val) if self.head is None: self.head = node else: t = self.head self.head = node self.head.next = t self.length += 1 def addAtTail(self, val): \"\"\" Append a node of value val to the last element of the linked list. :type val: int :rtype: None \"\"\" node = MyNode(val) if self.head is None: self.head = node else: head = self.head while head.next is not None: head = head.next head.next = node self.length += 1 def addAtIndex(self, index, val): \"\"\" Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. :type index: int :type val: int :rtype: None \"\"\" if index > self.length or (index = self.length or index Java class MyNode{ int val; MyNode next; public MyNode(int _val){ val = _val; next = null; } } class MyLinkedList { MyNode head; int length; /** Initialize your data structure here. */ public MyLinkedList() { length = 0; head = null; } /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ public int get(int index) { if(index = length){ return -1; } MyNode node = head; for(int i = 0; i length) || (index = length) ||index "},"708.html":{"url":"708.html","title":"708 Insert into a Cyclic Sorted List","keywords":"","body":"708 Insert into a Cyclic Sorted List tagsstart Linked List tagsstop Python 最简单思路，首先一个while循环找到最大值和最小值，第二个while循环将元素插到合适的位置中。注意特殊情况，就是插在链表最后端的时候。 \"\"\" # Definition for a Node. class Node(object): def __init__(self, val, next): self.val = val self.next = next \"\"\" class Solution(object): def insert(self, head, insertVal): \"\"\" :type head: Node :type insertVal: int :rtype: Node \"\"\" newNode = ListNode(insertVal) if head is None: newNode.next = newNode return newNode minVal = head.val maxVal = head.val prev, curr = head, head.next while curr != head: if minVal > curr.val: minVal = curr.val if maxVal = prev.val: prev.next = newNode newNode.next = curr return head if curr.val == minVal and prev.val == maxVal: if insertVal >= maxVal or insertVal "},"725.html":{"url":"725.html","title":"725 Split Linked List in Parts","keywords":"","body":"725 Split Linked List in Parts tagsstart Linked List tagsstop Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def splitListToParts(self, root, k): \"\"\" :type root: ListNode :type k: int :rtype: List[ListNode] \"\"\" length = 0 curr = root while curr: length +=1 curr = curr.next width = length / k remainder = length % k ans = [] cur = root for i in xrange(k): head = write = ListNode(None) for j in xrange(width + (i Java class Solution { public ListNode[] splitListToParts(ListNode root, int k) { ListNode cur = root; int N = 0; while (cur != null) { cur = cur.next; N++; } int width = N / k, rem = N % k; ListNode[] ans = new ListNode[k]; cur = root; for (int i = 0; i 编程注意事项 Java 和 Python 连续赋值的问题 Java 连续赋值： 自右向左逐一赋值 Python 连续赋值：从左向右 "},"726.html":{"url":"726.html","title":"726 Number of Atoms","keywords":"","body":"726 Number of Atoms tagsstart Hash Table Stack Recursion tagsstop 使用栈 进行括号处理， 比较麻烦的地方是字符串的预处理等等。 "},"817.html":{"url":"817.html","title":"817 Linked List Components","keywords":"","body":"817 Linked List Components tagsstart Linked List tagsstop Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def numComponents(self, head, G): \"\"\" :type head: ListNode :type G: List[int] :rtype: int \"\"\" Gset = set(G) cur = head ans = 0 while cur: if cur.val in Gset and (cur.next is None or cur.next.val not in Gset): ans += 1 cur = cur.next return ans Java class Solution { public int numComponents(ListNode head, int[] G) { Set Gset = new HashSet(); for (int x: G) Gset.add(x); ListNode cur = head; int ans = 0; while (cur != null) { if (Gset.contains(cur.val) && (cur.next == null || !Gset.contains(cur.next.val))) ans++; cur = cur.next; } return ans; } } "},"876.html":{"url":"876.html","title":"876 Middle of the Linked List","keywords":"","body":"876 Middle of the Linked List tagsstart Linked List tagsstop 快慢指针方法找中点 Python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def middleNode(self, head: 'ListNode') -> 'ListNode': fast = slow = head while fast and fast.next: fast = fast.next.next slow = slow.next return slow "},"1019.html":{"url":"1019.html","title":"1019 Next Greater Node in Linked List","keywords":"","body":"1019 Next Greater Node in Linked List tagsstart Linked List Stack Monostone Stack tagsstop 这个让我想到了使用单调栈的方法，进行处理，可以实现一边遍历就可以得到结果。 使用单调递减栈保存下标 单调栈和单调队列 单调栈和单调队列详解：https://endlesslethe.com/monotone-queue-and-stack-tutorial.html 单调栈，顾名思义就是栈内的元素保持一定的单调性的栈，这里的单调递增和单调递减都是从栈顶到栈尾的单调性 单调栈和单调队列和正常的栈以及队列使用上是相同的，单调栈满足的是后进先出，单调队列满足的是先进先出。 Python # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def nextLargerNodes(self, head): \"\"\" :type head: ListNode :rtype: List[int] \"\"\" nums = [] while head: nums.append(head.val) head = head.next stack = [] res = [0] * len(nums) for i, n in enumerate(nums): while stack and nums[stack[-1]] Java Java 代码写的很臭 需要多改 多练 import java.util.Vector; /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int[] nextLargerNodes(ListNode head) { Vector vt = new Vector(); ListNode curr = head; while(curr != null){ vt.add(new Integer(curr.val)); curr = curr.next; } Stack stack = new Stack(); int[] res = new int[vt.size()]; for(int i = 0; i "},"1081.html":{"url":"1081.html","title":"1081 Smallest Subsequence of Distinct Characters","keywords":"","body":"1081 Smallest Subsequence of Distinct Characters tagsstart String tagsstop 思路也是很奇妙的一道题，我们首先处理出来每个字符的index list, 在这个list中，我们每次按照字母的顺序，选取存在的第一个，出现的index小于其他后面后面任何的最后出现index. 例子如下： s = 'cdadabcc',scontainsa, b, c, dindex['a'] = [2, 4]index['b'] = [5]index['c'] = [0, 6, 7]index['d'] = [1, 3 Which will be the first letter in ans?It will be letter 'a', cause2 , (5,7,3) is thelast indexof other letters, after append 'a', now the index becomesindex['b'] = [5]index['c'] = [6, 7]index['d'] = [3] We delete all index less than 2. Obviously, the next letter will be 'd', analyse one by one. class Solution(object): def smallestSubsequence(self, text): \"\"\" :type text: str :rtype: str \"\"\" n = len(text) d = collections.defaultdict(collections.deque) for i, v in enumerate(text): d[ord(v) - ord('a')].append(i) keys = sorted(d.keys()) res = [] c = len(d) last_index = -1 while len(res) "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags Linked List Linked List 2 Add Two Numbers 19 Remove Nth Node From End of List 21 Merge Two Sorted Lists 23 Merge k Sorted Lists 24 Swap Nodes in Pairs 25 Reverse Nodes in k-Group 61 Rotate List 82 Remove Duplicates from Sorted List II 83 Remove Duplicates from Sorted List 86 Partition List 92 Reverse Linked List II 109 Convert Sorted List to Binary Search Tree 138 Copy List with Random Pointer 141 Linked List Cycle 142 Linked List Cycle II 143 Reorder List 147 Insertion Sort List 148 Sort List 160 Intersection of Two Linked List 203 Remove Linked List Elements 206 Reverse Linked List 234 Palindrome Linked List 237 Delete Node in a Linked List 328 Odd Even List 369 Plus One Linked List 379 Design Phone Directory 426 Convert Binary Search Tree to Sorted Doubly Linked List 430 Flatten a Multilevel Doubly Linked List 445 Add Two Numbers II 707 Design Linked List 708 Insert into a Cyclic Sorted List 725 Split Linked List in Parts 817 Linked List Components 876 Middle of the Linked List 1019 Next Greater Node in Linked List Binary Search Binary Search 4 Median of Two Sorted Arrays 29 Divide Two Integers 33 Search in Rotated Sorted Array 34 Find First and Last Position of Element in Sorted Array 35 Search Insert Position 50 Pow(x, n) 69 Sqrt 74 Search a 2D Matrix 153 Find Minimum in Rotated Sorted Array 154 Find Minimum in Rotated Sorted Array II 162 Find Peak Element 167 Two Sum II Input Array is sorted Array 1 Two Sum 4 Median of Two Sorted Arrays 11 Container With Most Water 15 3Sum 16 3Sum Closest 18 4Sum 26 Remove Duplicates from Sorted Array 27 Remove Element 31 Next Permutation 33 Search in Rotated Sorted Array 34 Find First and Last Position of Element in Sorted Array 35 Search Insert Position 39 Combination Sum 40 Combination Sum II 41 First Missing Positive 42 Trapping Rain Water 62 Unique Paths 63 Unique Paths II 64 Minimum Path Sum 74 Search a 2D Matrix 153 Find Minimum in Rotated Sorted Array 154 Find Minimum in Rotated Sorted Array II 162 Find Peak Element 167 Two Sum II Input Array is sorted 216 Combination Sum III 414 Third Maximum Number Hash Table 1 Two Sum 3 Longest Substring Without Repeating Characters 18 4Sum 30 Substring with Concatenation of All Words 36 Valid Sudoku 37 Sudoku Solver 138 Copy List with Random Pointer 141 Linked List Cycle 160 Intersection of Two Linked List 379 Design Phone Directory 451 Sort Characters By Frequency 726 Number of Atoms Math 2 Add Two Numbers 7 Reverse Integer 8 String to Integer (atoi) 9 Palindrome Number 12 Integer to Roman 13 Roman to Integer 29 Divide Two Integers 50 Pow(x, n) 69 Sqrt Two Pointers 3 Longest Substring Without Repeating Characters 11 Container With Most Water 15 3Sum 16 3Sum Closest 18 4Sum 19 Remove Nth Node From End of List 26 Remove Duplicates from Sorted Array 27 Remove Element 28 Implement strStr() 30 Substring with Concatenation of All Words 42 Trapping Rain Water 61 Rotate List 86 Partition List 141 Linked List Cycle 142 Linked List Cycle II 160 Intersection of Two Linked List 167 Two Sum II Input Array is sorted String 3 Longest Substring Without Repeating Characters 5 Longest Palindromic Substring 8 String to Integer (atoi) 10 Regular Expression Matching 12 Integer to Roman 13 Roman to Integer 14 Longest Common Prefix 17 Letter Combinations of a Phone Number 20 Valid Parentheses 22 Generate Parentheses 28 Implement strStr() 30 Substring with Concatenation of All Words 32 Longest Valid Parentheses 38 Count and Say 686 Repeated String Match 1081 Smallest Subsequence of Distinct Characters Sliding Window 3 Longest Substring Without Repeating Characters 683 K Empty Slots Divide and Conquer 4 Median of Two Sorted Arrays 23 Merge k Sorted Lists 215 Kth Largest Element in an Array 426 Convert Binary Search Tree to Sorted Doubly Linked List Dynamic Programming 5 Longest Palindromic Substring 10 Regular Expression Matching 32 Longest Valid Parentheses 62 Unique Paths 63 Unique Paths II 64 Minimum Path Sum 198 House Robber 377 Combination Sum IV Backtracking 10 Regular Expression Matching 17 Letter Combinations of a Phone Number 22 Generate Parentheses 37 Sudoku Solver 39 Combination Sum 40 Combination Sum II 77 Combinations 211 Add and Search Word - Data Structure Design 216 Combination Sum III 526 Beautiful Arrangement Stack 20 Valid Parentheses 42 Trapping Rain Water 726 Number of Atoms 1019 Next Greater Node in Linked List Heap 23 Merge k Sorted Lists 215 Kth Largest Element in an Array 451 Sort Characters By Frequency 703 Kth Largest Element in a Stream Tree 98 Valid Binary Tree 426 Convert Binary Search Tree to Sorted Doubly Linked List Depth-first Search 98 Valid Binary Tree 109 Convert Sorted List to Binary Search Tree 200 Numbers of Islands 430 Flatten a Multilevel Doubly Linked List Sort 147 Insertion Sort List 148 Sort List Breadth-first Search 200 Numbers of Islands Union Find 200 Numbers of Islands Design 208 Implement Trie(Prefix Tree) 211 Add and Search Word - Data Structure Design 379 Design Phone Directory 707 Design Linked List Trie 208 Implement Trie(Prefix Tree) 211 Add and Search Word - Data Structure Design Queue 379 Design Phone Directory Ordered Map 683 K Empty Slots Binary Search Tree 683 K Empty Slots Recursion 726 Number of Atoms Monostone Stack 1019 Next Greater Node in Linked List "}}