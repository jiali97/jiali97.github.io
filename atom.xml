<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiali&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-03T23:35:29.052Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xingjiali Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lab 01 Bomb Lab</title>
    <link href="http://yoursite.com/2019/09/03/lab01/"/>
    <id>http://yoursite.com/2019/09/03/lab01/</id>
    <published>2019-09-03T22:15:12.000Z</published>
    <updated>2019-09-03T23:35:29.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 这个实验要很小心很小心的做，因为会炸。</p></blockquote><a id="more"></a><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>GDB 调试基础 <a href="http://csapp.cs.cmu.edu/2e/docs/gdbnotes-x86-64.pdf" target="_blank" rel="noopener">GDB</a> 常用命令</li><li>Assembly Language 汇编语言 基本命令</li></ul><h4 id="0x01-strcmp"><a href="#0x01-strcmp" class="headerlink" title="0x01 strcmp()"></a>0x01 strcmp()</h4><p><img src="/2019/09/03/lab01/strcmp.png" alt></p><p>仔细看这段汇编代码，里面首先从0x804a6b8这个位置获取的变量移到$ebp-0xc位置中，然后调用strings_not_equal() 函数，传入我们的输入$ebp+0x8 这个字符串，以及刚刚获取到的变量。结果存在$eax寄存器中，然后使用test指令对于$eax中保存的结果进行处理。test指令对于两个操作数进行and操作，并根据结果对于ZF进行标记。如果and操作为零，则ZF标志为1。而je指令在ZF被置位的时候跳转。因此我们需要上一个 调用函数的返回值为0。</p><p>我们再研究一下这个函数strings_not_equal() 这个函数。</p><p><img src="/2019/09/03/lab01/zxjl/security_lab/lab01/string_not_equal.png" alt="image-20190830182110872"></p><p>对于传入的两个字符串变量首先进行计算长度（调用string_length()）函数，然后将数据存储在的eax和ebx两个寄存器中的数据，进行比较。如果长度相等，则继续调用后面的函数进行比较。否则，返回1.C语言代码如下。 比较两个字符串，相同返回0，不同返回1。</p><p><img src="/2019/09/03/lab01/strcmp_c.png" alt></p><p>因此我们需要输入和题目字符串中相同的字符串量。<code>&quot;What were the last four digits of your childhood telephone number?&quot;</code></p><h4 id="0x02-funcall"><a href="#0x02-funcall" class="headerlink" title="0x02 funcall"></a>0x02 funcall</h4><p>注意加断点！加断点！加断点！不要让程序去一个你不知道的地方。首先看汇编。</p><p><img src="/2019/09/03/lab01/funcall.png" alt></p><p>程序传入了三个字符串，然后调用了一个叫func_game()的函数。在func_game()函数中，传入了4个参数，分别是(input_string, “rock”,”paper”,”scissors”) 分别存储在$ebp+0x8, $ebp+0xc,$ebp+0x10, $ebp+0x14位置。然后将其传入本地变量中进行保存，同时调用string_not_equal()函数进行处理，如果出现不同的情况，eax返回为1，将不进行跳转，对于$ebp-0xc中的变量进行加一操作。最后，从第72行开始，判断$ebp-0xc中变量中的值，如果不是2的话，则bomb，否则输出key. 我们在string_not_equal()函数进行加断点处理，看这个函数的参数是那两个，就可以知道我们需要输入的是那个啦。</p><p><img src="/2019/09/03/lab01/func_game.png" alt="image-20190901130726013"></p><h4 id="0x03-password"><a href="#0x03-password" class="headerlink" title="0x03 password"></a>0x03 password</h4><p>废话不多说，直接上汇编。</p><p><img src="/2019/09/03/lab01/zxjl/security_lab/lab01/password.png" alt="image-20190901143505513"></p><p>注意里面对于输入的字符串调用了一个strings_equal()函数，并且需要这个函数的返回值为1（因为后续经过一个test指令加上一个jne指令），也就是和这个字符串不同，在strings_equal()函数里面，对两个字符串进行取长度操作，并将长度作为返回值的依据，如果长度相等，则返回0， 不同则返回1。因此，我们只需要输入一个长度不同于11的字符串便可以解除这个炸弹了。</p><h4 id="0x04-quick"><a href="#0x04-quick" class="headerlink" title="0x04 quick"></a>0x04 quick</h4><p><img src="/2019/09/03/lab01/quick.png" alt="image-20190903111946542"></p><p>首先调用read_six_number() 函数，暗示我们需要输入6个数字，将数字存储在eax寄存器所指向的$ebp-0x24这个位置。然后将第一个数字的位置，$ebp-0x24位置的数字进行test 然后通过jns进行跳转。所以要求第一个位置的数字不得小于0。之后通过$eax, $ebx，$ecx, 以及$edx四个寄存器进行循环判断，相对应位置的值是否满足条件a[i] = a[i-1] + i，如果不满足就bomb.</p><p>因此，我们只要输入符合要求的一组数据即可。</p><h4 id="0x05-jump"><a href="#0x05-jump" class="headerlink" title="0x05 jump"></a>0x05 jump</h4><p>先上汇编</p><p><img src="/2019/09/03/lab01/jump.png" alt></p><p><img src="/2019/09/03/lab01/jump2.png" alt="image-20190903113617822"></p><p>jump函数首先调用sscanf()函数，从输入字符串中读取两个数，读到$ebp-0x14和$ebp-0x18中,  并且返回读到数字的个数在$eax中。首先判断返回值是否大于1， 不大于则bomb。 紧接着判断$ebp-0x14这个数是否比7大，如果超过7，则bomb。然后进行条件跳转，按照$ebp-0x14中读到的数进行跳转。如果输入的为零，则跳转到0x804951e这个位置。最后将对应数字进行比较，如果不相等，则跳转bomb.</p><h4 id="0x06-binary"><a href="#0x06-binary" class="headerlink" title="0x06 binary"></a>0x06 binary</h4><p>和前面的类似，读取两个数到$ebp-0x18以及$ebp-0x1c这两个位置，然后将返回值所在的$eax位置的数据和2进行比较，所以输入的必须是两个数字。然后将读到的第一个数字和0以及和e(16进制数，换成十进制就是14) 进行比较，如果小于0或者大于14都将爆炸。然后调用func4()函数，通过几个判断指令，控制程序的跳转。func4()函数的返回值必须为11。通过测试以及计算，1 11符合条件。</p><h4 id="0x07-array"><a href="#0x07-array" class="headerlink" title="0x07 array"></a>0x07 array</h4><p>和前面类似，读取两个数到$ebp-0x18以及$ebp-0x1c这两个位置。使用代码进行计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0xa</span>, <span class="number">2</span>, <span class="number">0xe</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0xc</span>, <span class="number">0xf</span>, <span class="number">0xb</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0xd</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v3 <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">    v3_bak = v3</span><br><span class="line">    <span class="keyword">for</span> v2 <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1000</span>):</span><br><span class="line">        v3 = v3_bak</span><br><span class="line">        v3 &amp;= <span class="number">0xf</span></span><br><span class="line">        v6 = <span class="number">0</span></span><br><span class="line">        v5 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> v3 != <span class="number">15</span>:</span><br><span class="line">            v6 += <span class="number">1</span></span><br><span class="line">            v3 = a[v3]</span><br><span class="line">            v5 += v3</span><br><span class="line">            <span class="keyword">if</span> v6 == <span class="number">15</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> v6 == <span class="number">15</span> <span class="keyword">and</span> v5 == v2:</span><br><span class="line">            print(v3_bak, v2)</span><br></pre></td></tr></table></figure><h4 id="0x08-list"><a href="#0x08-list" class="headerlink" title="0x08 list"></a>0x08 list</h4><p>首先调用read_six_number()函数，暗示我们的输入是6个数字。然后通过一个循环，要求每个数字都不一样，同时在1-6这个范围中。逻辑比较麻烦，但是还是可以理解的。注意观察到里面的一个链表结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a1 <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">    <span class="keyword">for</span> a2 <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> a3 <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">            <span class="keyword">for</span> a4 <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                <span class="keyword">for</span> a5 <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                    <span class="keyword">for</span> a6 <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            node = &#123;</span><br><span class="line">                                <span class="number">0x804c4e0</span>: [<span class="number">0x351</span>, <span class="number">1</span>, <span class="number">0x804c4d4</span>],</span><br><span class="line">                                <span class="number">0x804c4d4</span>: [<span class="number">0x127</span>, <span class="number">2</span>, <span class="number">0x804c4c8</span>],</span><br><span class="line">                                <span class="number">0x804c4c8</span>: [<span class="number">0x144</span>, <span class="number">3</span>, <span class="number">0x804c4bc</span>],</span><br><span class="line">                                <span class="number">0x804c4bc</span>: [<span class="number">0x31e</span>, <span class="number">4</span>, <span class="number">0x804c4b0</span>],</span><br><span class="line">                                <span class="number">0x804c4b0</span>: [<span class="number">0x3df</span>, <span class="number">5</span>, <span class="number">0x804c4a4</span>],</span><br><span class="line">                                <span class="number">0x804c4a4</span>: [<span class="number">0x250</span>, <span class="number">6</span>, <span class="number">0</span>]</span><br><span class="line">                            &#125;</span><br><span class="line">                            v2 = [<span class="number">0</span>] * <span class="number">6</span></span><br><span class="line">                            v3 = [a1, a2, a3, a4, a5, a6]</span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">                                <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">                                    <span class="keyword">if</span> v3[i] == v3[j]:</span><br><span class="line">                                        <span class="keyword">raise</span> Exception()</span><br><span class="line">                            <span class="comment"># print(v3)</span></span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">6</span>):</span><br><span class="line">                                v7 = <span class="number">0x804c4e0</span></span><br><span class="line">                                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, v3[i]):</span><br><span class="line">                                    v7 = node[v7][<span class="number">2</span>]</span><br><span class="line">                                v2[i] = v7</span><br><span class="line">                            v4 = v2[<span class="number">0</span>]</span><br><span class="line">                            v7 = v2[<span class="number">0</span>]</span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">                                node[v7][<span class="number">2</span>] = v2[i]</span><br><span class="line">                                v7 = node[v7][<span class="number">2</span>]</span><br><span class="line">                            node[v7][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">                            v7 = v4</span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">                                <span class="keyword">if</span> node[v7][<span class="number">0</span>] &gt; node[node[v7][<span class="number">2</span>]][<span class="number">0</span>]:</span><br><span class="line">                                    <span class="keyword">raise</span> Exception()</span><br><span class="line">                                v7 = node[v7][<span class="number">2</span>]</span><br><span class="line">                            print(v3)</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            <span class="comment"># print(str(e))</span></span><br><span class="line">                            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h4 id="0x09-pi"><a href="#0x09-pi" class="headerlink" title="0x09 pi"></a>0x09 pi</h4><p>在compute_pi()函数计算结束时候，查看相对应的内存即可。</p><h4 id="0x10-secret"><a href="#0x10-secret" class="headerlink" title="0x10 secret"></a>0x10 secret</h4><p>secret() 函数里面存在迭代，使用下面函数进行求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    <span class="number">0x804c594</span>: [<span class="number">0x24</span>, <span class="number">0x804c588</span>, <span class="number">0x804c57c</span>],</span><br><span class="line">    <span class="number">0x804c588</span>: [<span class="number">0x8</span>, <span class="number">0x804c558</span>, <span class="number">0x804c570</span>],</span><br><span class="line">    <span class="number">0x804c57c</span>: [<span class="number">0x32</span>, <span class="number">0x804c564</span>, <span class="number">0x804c54c</span>],</span><br><span class="line">    <span class="number">0x804c570</span>: [<span class="number">0x16</span>, <span class="number">0x804c504</span>, <span class="number">0x804c51c</span>],</span><br><span class="line">    <span class="number">0x804c564</span>: [<span class="number">0x2d</span>, <span class="number">0x804c540</span>, <span class="number">0x804c4f8</span>],</span><br><span class="line">    <span class="number">0x804c558</span>: [<span class="number">0x6</span>, <span class="number">0x804c534</span>, <span class="number">0x804c510</span>],</span><br><span class="line">    <span class="number">0x804c54c</span>: [<span class="number">0x6b</span>, <span class="number">0x804c528</span>, <span class="number">0x804c4ec</span>],</span><br><span class="line">    <span class="number">0x804c540</span>: [<span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">0x804c534</span>: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">0x804c528</span>: [<span class="number">0x63</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">0x804c51c</span>: [<span class="number">0x23</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">0x804c510</span>: [<span class="number">0x7</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">0x804c504</span>: [<span class="number">0x14</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">0x804c4f8</span>: [<span class="number">0x2f</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">0x804c4ec</span>: [<span class="number">0x3e9</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func7</span><span class="params">(a1, a2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a1 == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> a2 &lt; d[a1][<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func7(d[a1][<span class="number">1</span>], a2)</span><br><span class="line">    <span class="keyword">if</span> a2 == d[a1][<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * func7(d[a1][<span class="number">2</span>], a2) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v1 <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10001</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="keyword">if</span> func7(<span class="number">0x804c594</span>,  v1) == <span class="number">5</span>:</span><br><span class="line">            print(v1)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(str(e))</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 这个实验要很小心很小心的做，因为会炸。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Lab" scheme="http://yoursite.com/categories/Lab/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习</title>
    <link href="http://yoursite.com/2019/08/17/Go/"/>
    <id>http://yoursite.com/2019/08/17/Go/</id>
    <published>2019-08-17T21:49:50.000Z</published>
    <updated>2019-08-18T04:51:46.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go-特色"><a href="#Go-特色" class="headerlink" title="Go 特色"></a>Go 特色</h3><ul><li>简洁，快速，安全</li><li>并行，有趣，开源</li><li>内存管理，数组安全，编译迅速</li></ul><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li><code>go run</code> 执行<code>Go</code>语言代码</li><li><code>go build</code> 生成二进制文件</li></ul><h3 id="Go-语言的基本组成"><a href="#Go-语言的基本组成" class="headerlink" title="Go 语言的基本组成"></a>Go 语言的基本组成</h3><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句&amp;表达式</li><li>注释</li></ul><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Go-特色&quot;&gt;&lt;a href=&quot;#Go-特色&quot; class=&quot;headerlink&quot; title=&quot;Go 特色&quot;&gt;&lt;/a&gt;Go 特色&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;简洁，快速，安全&lt;/li&gt;
&lt;li&gt;并行，有趣，开源&lt;/li&gt;
&lt;li&gt;内存管理，数组安全，编译迅速&lt;/
      
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Web_AI</title>
    <link href="http://yoursite.com/2019/08/14/Web-AI/"/>
    <id>http://yoursite.com/2019/08/14/Web-AI/</id>
    <published>2019-08-15T03:56:09.000Z</published>
    <updated>2019-08-15T03:56:09.885Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 就该这么学</title>
    <link href="http://yoursite.com/2019/08/09/linux/"/>
    <id>http://yoursite.com/2019/08/09/linux/</id>
    <published>2019-08-09T14:12:13.000Z</published>
    <updated>2019-08-13T21:50:24.906Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/08/09/linux/Linux.jpg" alt></p><a id="more"></a><blockquote><p>Linux, 一切皆文件。</p></blockquote><h4 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h4><ol><li><code>echo [字符串| $变量]</code>: 在终端输出字符串或变量提取后的值</li><li><code>date</code>: 显示以及设置系统时间和日期，<code>+s</code>参数可以设置当前的时间和日期</li><li><code>reboot</code>: 重启系统，默认需要管理员权限</li><li><code>poweroff</code>: 关闭系统，需要<code>root</code>权限</li><li><code>wget</code>: 用于在终端中下载网络文件</li><li><code>ps</code>: 用于查看系统中的进程状态</li><li><code>top</code>: 动态地监视进程活动与系统负载等信息</li><li><code>pidoff</code>: 用于查询某个指定服务进程的PID值</li><li><code>kill</code>: 用于终止某个指定PID的服务进程</li><li><code>killall</code>: 用于终止某个指定名称的服务所对应的全部进程</li></ol><h4 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h4><ol><li><code>ifconfig</code>: 获取网卡与网络状态信息</li><li><code>uname</code>: 用于查看系统内核与系统版本等信息，可以附加<code>-a</code>参数</li><li><code>uptime</code>：用于查看系统的负载信息</li><li><code>free</code>: 显示系统中内存的使用量信息</li><li><code>who</code>: 用于查看当前登入主机的用户终端信息</li><li><code>last</code>: 用于查看所有系统的登录记录</li><li><code>history</code>: 可以显示历史执行过的命令信息 可以使用<code>-c</code>参数进行清除</li><li><code>sosreport</code>: 用于收集系统配置及架构信息并输出诊断文档</li></ol><h4 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h4><ol><li><code>pwd</code>: 显示用户当前所处的工作目录</li><li><code>cd</code>: 用于切换工作路径，<code>-</code> 为上一次的目录</li><li><code>ls</code>: 显示目录中的文件信息， 常用参数<code>-ald</code></li></ol><h4 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h4><ol><li><code>cat</code>:  用于查看文本文件，内容比较少的。显示行号添加<code>-n</code> 参数</li><li><code>more</code>: 用于查看文本文件，内容比较多的</li><li><code>head</code>: 用于查看纯文本文件的前N行</li><li><code>tail</code>: 用于查看纯文本文件的后N行</li><li><code>tr</code>: 用于替换文本文件中的字符</li><li><code>wc</code>: 用于统计指定文本的行数<code>-l</code>，字数<code>-w</code>，字节数<code>-c</code></li><li><code>stat</code>: 用于查看文件的具体存储信息和时间等信息</li><li><code>cut</code>: 用于按“列”提取文本字符， 使用<code>-d</code>设置分隔符，使用<code>-f</code>设置列数</li><li><code>diff</code>: 用于比较多个文本文件的差异， 使用<code>-c</code>参数描述文件的具体不同</li></ol><h4 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h4><ol><li><code>touch</code>: 创建新的文件或者设置文件的时间</li><li><code>mkdir</code>: 创建空白的目录, 使用<code>-p</code>参数进行递归迭代</li><li><code>cp</code>: 用于复制文件或目录, 常用参数<code>-p</code>保留原始文件的属性，<code>-r</code> 用于对目录的递归复制，<code>-d</code>用于保留连接文件的属性</li><li><code>mv</code>: 用于文件剪切或者将文件重新命名</li><li><code>rm</code>:  用于删除文件或者目录，<code>-r</code>删除目录，<code>-f</code>强制删除</li><li><code>dd</code>:  用于按照指定大小和个数的数据块来复制文件或者转换文件，之前用在刻录系统盘的时候， 常用参数<code>if</code> 输入文件的名称 <code>of</code> 输出文件的名称，<code>bs</code>每个块儿的大小，<code>count</code> 要复制的块儿个数</li><li><code>file</code>: 查看文件类型</li></ol><h4 id="打包压缩和搜索命令"><a href="#打包压缩和搜索命令" class="headerlink" title="打包压缩和搜索命令"></a>打包压缩和搜索命令</h4><ol><li><p><code>tar</code>： 文件打包压缩和解压</p><p>常见参数：</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">创建压缩文件</td></tr><tr><td align="center">-x</td><td align="center">解来压缩文件</td></tr><tr><td align="center">-t</td><td align="center">查看压缩包内有那些文件</td></tr><tr><td align="center">-z</td><td align="center">使用Gzip压缩或者解压</td></tr><tr><td align="center">-j</td><td align="center">使用bzip2压缩或者解压</td></tr><tr><td align="center">-v</td><td align="center">显示压缩或者解压的过程</td></tr><tr><td align="center">-f</td><td align="center">目标文件名</td></tr><tr><td align="center">-p</td><td align="center">保留原始文件权限和属性</td></tr><tr><td align="center">-P</td><td align="center">使用绝对路径进行压缩</td></tr><tr><td align="center">-C</td><td align="center">指定解压到目录</td></tr></tbody></table></li><li><p><code>grep</code>: 用于在文本中执行关键词搜索，并显示匹配的结果<code>-n</code> 显示行号，<code>-v</code> 进行搜索反选</p></li><li><p><code>find</code>: 按照指定条件来查找文件,<code>-name</code> 匹配名称，<code>-size</code>匹配大小，<code>-exec</code> 将find命令找到的结果交由紧接着的命令作后续处理， 配套使用参数<code>-exec {} \;</code></p></li><li><p>Linux进程中有这样的5个状态，分别为运行(R)，中断(S)，不可中断(D)，僵死(Z)和停止(T)。</p></li></ol><h4 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h4><blockquote><p>标准输入重定向（STDIN, 文件描述符0）</p><p>标准输出重定向（STDOUT, 文件描述符1）</p><p>标准错误重定向（STDERR，文件描述符2) </p></blockquote><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &lt; 文件</td><td>将文件作为命令的标准输入</td></tr><tr><td>命令 &lt;&lt; 分隔符</td><td>从标准输入中读入，直到遇到分界符才停止</td></tr><tr><td>命令 &lt; 文件1 &gt; 文件2</td><td>将文件1作为命令的标准输入，并将标准输出输出到文件2</td></tr></tbody></table><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>命令 &gt; 文件</td><td>将标准输出到文件（清空原有文件数据）</td></tr><tr><td>命令 2&gt; 文件</td><td>将错误输出到文件（清空原有文件数据）</td></tr><tr><td>命令 &gt;&gt; 文件</td><td>将标准输出到文件（追加）</td></tr><tr><td>命令 2&gt;&gt; 文件</td><td>将错误输出到文件（追加）</td></tr><tr><td>命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件</td><td>将标准输出与错误输出共同写到文件中（追加）</td></tr></tbody></table><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><ul><li><p>管道命令符: <code>命令1|命令2</code>： 把前一个命令原本要输入到屏幕的数据当做是后一个命令的标准输入</p></li><li><p>命令符的通配符：<code>*</code>匹配零个或者多个字符，<code>?</code>匹配单个字符，<code>[0-9]</code>，中括号加内容，匹配其中内容一个部分</p></li><li><p>转义字符: <code>\</code>反斜线，<code>&#39;</code>单引号，<code>&quot;</code>双引号，```反引号</p></li><li><p>环境变量：Linux中对于命令的查找，不同用户不同的环境变量</p></li></ul><h4 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h4><ol><li>三种模式： 命令模式，插入模式，普通模式。</li><li>命令模式中常用的命令：<code>[X]dd</code> 删除光标所在[X]行，<code>n</code>显示搜索命令定位的下一个字符串，<code>N</code>显示搜索命令定位的上一个字符串，<code>u</code> 撤销上一步操作。</li><li>普通模式中常用的命令: <code>:wq</code>保存退出，<code>:q!</code>强制退出，不保存修改，<code>/字符串</code>搜索该字符串</li><li>普通用户编辑文件如何保存： <code>:w !sudo tee %</code></li></ol><h4 id="编写Shell脚本"><a href="#编写Shell脚本" class="headerlink" title="编写Shell脚本"></a>编写Shell脚本</h4><ol><li>脚本类型: 交互式以及批处理</li><li>接收用户的参数：<code>$&lt;number&gt;</code></li><li>条件语句，循环语句，判断语句</li></ol><h4 id="用户身份和文件权限"><a href="#用户身份和文件权限" class="headerlink" title="用户身份和文件权限"></a>用户身份和文件权限</h4><ol><li><p><code>root</code>用户<code>UID</code>为0， 系统用户<code>UID</code>为1-999， 普通用户从1000开始</p></li><li><p><code>useradd</code>: <code>-d</code>指定家目录，<code>-d</code>指定账户到期时间，<code>-g</code>指定一个初始的用户基本组，<code>-s</code>指定用户默认的<code>shell</code>解释器，<code>/sbin/nologin</code>说明用户不能够登录到系统中，可以设置为<code>FTP</code>管理员的登录权限，做到系统权限最小化，以及各个不同功能的隔离。</p></li><li><p><code>groupadd</code>: 用于创建用户组</p></li><li><p><code>usermod</code>:  用于修改用户的属性</p></li><li><p><code>passwd</code>: 用于修改用户密码，过期时间，认证信息等等， <code>root</code>管理员修改密码时候，不用验证旧密码， <code>-l</code>锁定用户，禁止其登录，<code>-u</code>解除锁定，允许其登录</p></li><li><p><code>userdel</code>：用于删除用户</p></li><li><p>Linux中的文件类型: <code>-</code>: 普通文件，<code>d</code>目录文件，<code>l</code>链接文件，<code>b</code>块设备文件，<code>c</code>字符设备文件，<code>p</code>管道文件</p></li><li><p>文件权限: 读写执行<code>421</code></p></li><li><p><code>chmod</code> : 设置文件或者目录的权限，<code>-R</code> 表示递归操作</p></li><li><p>特殊权限</p><ul><li><code>SUID</code>: 对于二进制程序设置的特殊权限，可以让二进制程序的执行者临时拥有属主的权限（仅对拥有执行权限的二进制程序有效），一种有条件的，临时的特殊权限授予方法。</li><li><code>SGID</code>: 让执行者临时拥有属组的权限（对用用执行权限的二进制程序进行设置），在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置</li><li><code>SBIT</code>： 粘滞位。当对于某个目录设置了这个粘滞位之后，这个目录中的文件只能被其所有者执行删除操作</li></ul></li><li><p>隐藏权限</p><ul><li><code>chattr</code>: 设置文件的隐藏权限，保证文件的安全</li><li><code>lsattr</code>: 显示文件的隐藏权限</li></ul></li><li><p>文件访问控制列表<code>ACL</code></p><ul><li><code>setfacl</code>: 管理文件的ACL规则</li><li><code>getfacl</code>: 显示文件上设置的ACL信息</li></ul></li><li><p>身份切换</p><ul><li><code>su</code>: 使用<code>su -</code>, 切换到新的用户，使用减号表示将环境变量的信息也进行更新，而不是保留之前的环境变量信息</li><li><code>sudo</code>: 使用<code>sudo</code>命令提供给普通用户额外的权限来完成原本<code>root</code>管理员才能完成的任务</li><li><code>/etc/sudoers</code>: 提供集中的用户管理，权限与主机配置等</li><li><code>visudo</code>: 修改配置文件，只有<code>root</code>管理员有这个权限</li></ul></li></ol><h4 id="存储结构与磁盘划分"><a href="#存储结构与磁盘划分" class="headerlink" title="存储结构与磁盘划分"></a>存储结构与磁盘划分</h4><ol><li><p>按照文件系统层次化标准<code>FHS</code>采用树形结构存放文件</p></li><li><p>Linux中常见目录和内容</p><table><thead><tr><th>目录名称</th><th>放置文件信息</th></tr></thead><tbody><tr><td>/boot</td><td>开机所需要文件，开机菜单以及所需要的配置文件等</td></tr><tr><td>/dev</td><td>以文件形式存放设备与接口</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>用户家目录</td></tr><tr><td>/bin</td><td>存放单用户模式下还可以操作的命令</td></tr><tr><td>/lib</td><td>开机时候用到的函数库，以及/bin和/sbin下面的命令要调用的函数</td></tr><tr><td>/sbin</td><td>开机过程中需要的命令</td></tr><tr><td>/media</td><td>用于挂载设备文件的命令</td></tr><tr><td>/opt</td><td>放置第三方的软件</td></tr><tr><td>/root</td><td>系统管理员的家目录</td></tr><tr><td>/srv</td><td>一些网络服务的数据文件目录</td></tr><tr><td>/tmp</td><td>任何人均可使用的共享临时目录</td></tr><tr><td>/proc</td><td>虚拟文件系统，利用系统内核，进程，外部设备以及网络状况等</td></tr><tr><td>/usr/local</td><td>用户自行安装的软件</td></tr><tr><td>/usr/sbin</td><td>Linux系统开机时候不会用到的软件/命令/脚本</td></tr><tr><td>/usr/share</td><td>帮助与说明文件，也可放置共享文件</td></tr><tr><td>/var</td><td>主要存放时常变化的文件，比如日志</td></tr><tr><td>/lost+found</td><td>当文件系统发生错误的时候，将一些丢失的文件片段存放在这里</td></tr></tbody></table></li><li><p>绝对路径和相对路径</p></li><li><p>主分区或者扩展分区的编号从1开始，到4结束</p></li><li><p>/dev/sda5` 路径详解</p><p><code>/dev</code>: 硬件设备文件所在的目录</p><p><code>sd</code>: 存储设备</p><p><code>a</code>: 同类接口中的第一个被识别到的设备</p><p><code>5</code>: 表示这个设备是一个逻辑分区</p></li><li><p>磁盘硬件相关知识: 磁盘硬件是由大量扇区组成的，每个扇区的容量是<code>512</code>字节，第一个扇区中保存了主引导分区（MBR）以及分区表。</p></li><li><p>第一个扇区只能创建出4个分区，所以将第一个扇区的分区表，作为指向扩展分区的指针。从而添加扩展分区，再在扩展分区中创建不同的逻辑分区。</p></li><li><p>super block: Linux系统中的硬盘地图，<code>inode</code>记录以下信息</p><ul><li>文件的访问权限</li><li>所有者和所有组</li><li>文件大小</li><li>文件创建或内容修改时间</li><li>文件最后访问时间</li><li>文件的特殊权限</li><li>文件的真实数据地址</li></ul></li><li><p><code>mount</code>: 文件系统挂载</p></li><li><p><code>unmount</code>: 文件系统撤销挂载</p></li><li><p><code>fdisk</code>: 管理磁盘分区，添加，删除，转换分区等一站式分区服务</p></li><li><p><code>mkfs</code>: 进行格式化操作的命令</p></li><li><p><code>df -h</code>: 查看挂载状况以及磁盘使用情况</p></li><li><p><code>du</code>: 查看文件数据占用量</p></li><li><p>使挂载配置始终生效：<code>/etc/fstab</code></p></li><li><p>交换分区</p><ul><li><code>mkswap</code>: 添加交换分区</li><li><code>swapon</code>: 将交换分区正式挂载到系统中</li><li><code>free -m</code>:  查看交换分区的大小变化</li></ul></li><li><p><code>quota</code>: 磁盘容量限额管理, 相关命令<code>xfs_quota</code>, <code>edquota</code></p></li><li><p>软硬链接</p><ul><li>硬链接:指向原始文件<code>inode</code>的指针, 由于技术局限性，我们不能够跨分区对于文件进行链接</li><li>软链接:也称为符号链接，仅包含所链接文件的路径名，也可以跨越文件系统进行链接。</li><li><code>ln</code> : 创建链接文件，使用<code>-s</code>参数创建软链接</li></ul></li></ol><h4 id="RAID以及LVM技术"><a href="#RAID以及LVM技术" class="headerlink" title="RAID以及LVM技术"></a>RAID以及LVM技术</h4><ul><li><code>RAID</code> 技术： 磁盘阵列，具有数据备份以及高效查询的作用</li><li><code>LVM</code>逻辑卷管理器： 在硬盘分区和文件系统之间添加了一个逻辑层。</li></ul><h4 id="iptables-以及防火墙"><a href="#iptables-以及防火墙" class="headerlink" title="iptables 以及防火墙"></a>iptables 以及防火墙</h4><ol><li><code>iptables</code> 服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以称之为一个规则链，具体有如下几个：<ul><li>在进行路由选择之前处理数据包：<code>PREROUTING</code></li><li>处理流入的数据包:<code>INPUT</code></li><li>处理流出的数据包:<code>OUTPUT</code></li><li>处理转发的数据包:<code>FORWARD</code></li><li>在进行路由选择后处理数据包:<code>POSTROUTING</code></li></ul></li><li><code>iptables</code>操作响应<code>ACCEPT</code>,<code>REJECT</code>, <code>LOG</code>, <code>DROP</code></li></ol><h4 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h4><ol><li><p>网络参数配置命令</p><ul><li><code>ifconfig</code>: 手动的启动观察和修改网络接口的相关参数</li><li><code>ifup</code>： 使用配置文件进行网络接口配置时使用参数, 配置文件位置：<code>/etc/sysconfig/network-scripts</code></li><li><code>ifdown</code>: 同上</li><li><code>route</code>： 路由修改</li><li><code>ip</code>：配置基本网络参数，还能进行额外的IP协议，以及多IP的达成</li><li><code>iwlist</code>： 利用无线网卡进行无线<code>AP</code>的侦测与获得相关的数据</li><li><code>iwconfig</code>： 配置无线网卡的相关参数</li><li><code>dhclient</code>： 使用<code>dhcp</code>协议在局域网内获取<code>IP</code></li></ul></li><li><p>网络侦错与观察命令</p><ul><li><code>ping</code>: 发送一个特殊的网络数据包，成为<code>ICMP ECHO_REQUEST</code>包, 到另一个主机或者终端，可以试验连通性</li><li><code>traceroute</code>: 显示从本地到指定主机要经过的全部跳数的网络流量包</li><li><code>netstat</code>: 显示网络设置和网卡信息，<code>-r</code>显示路由包</li><li><code>host</code>: 查看某个主机的<code>IP</code></li><li><code>nslookup</code>:  查看某个主机的<code>IP</code>, 使用<code>/etc/resolv.conf</code> 文件作为<code>DNS</code>服务器的来源</li></ul></li><li><p>传输</p><ul><li><code>ftp</code>: ftp可以与FTP服务器进行通信，可以通过网络进行下载和上传</li><li><code>lftp</code>: 多协议的支持，下载失败会重新连，<code>Tab</code>键进行路径补全</li><li><code>wget</code>: 下载数据</li><li><code>ssh</code>: 和远程主机建立安全交流通道</li><li><code>scp</code>： <code>ssh</code>程序中附带，可以使用进行文件传输</li><li><code>sftp</code>:  <code>ssh</code>程序中附带，可以进行类似于<code>ftp</code>服务器的操作</li><li><code>telnet</code>： 远程连接， 可以连接到远程机器的<code>telnet</code>服务</li></ul></li><li><p>封包截取功能</p><ul><li><code>tcptump</code></li><li><code>ethereal</code></li><li><code>nc</code>: 网络的瑞士军刀，可以开放端口，传输文件，文字，接受反传等等</li></ul></li></ol><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>《Linux就该怎么学》</li><li>《鸟哥的Linux 私房菜》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/08/09/linux/Linux.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 实用指南</title>
    <link href="http://yoursite.com/2019/08/08/git/"/>
    <id>http://yoursite.com/2019/08/08/git/</id>
    <published>2019-08-08T21:38:49.000Z</published>
    <updated>2019-08-09T01:18:47.641Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/08/08/git/git.png" alt></p><a id="more"></a><blockquote><p>最近用git结果傻了，不小心把东西给删了，一边抱怨自己的傻，脑子不够用，一边觉得是自己真心基本命令不熟，本来的版本管理现在只知道个push和pull，出了问题就不知道怎么对付，心疼自己，顺便出一份指南，省的之后忘了这个怎么用。 </p></blockquote><h4 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h4><p>Git，简而言之就是一个世界上最先进的分布式版本控制系统。CVS和SVN都是集中式的版本控制系统，版本都是存放在中央服务器中的，如果不能联网的话，就没有正确的代码。而分布式的系统中，每个人的电脑中都是一个完整的版本库。</p><h4 id="Git原理"><a href="#Git原理" class="headerlink" title="Git原理"></a>Git原理</h4><p><img src="/2019/08/08/git/git_workflow.png" alt></p><h4 id="Git-获取仓库"><a href="#Git-获取仓库" class="headerlink" title="Git 获取仓库"></a>Git 获取仓库</h4><p><code>git init</code>: 创建Git可以管理的仓库，当前目录下会多一个<code>.git</code>文件夹。</p><p><code>git clone /path/to/repo</code>: 检出仓库。</p><p><code>git clone username@host:/path/to/repo</code>: 从远程服务器中检出仓库。</p><h4 id="Git-日常操作"><a href="#Git-日常操作" class="headerlink" title="Git 日常操作"></a>Git 日常操作</h4><p><code>git add file</code> : 计划改动，将文件提交到缓冲区中， 将对文件的修改提交到暂存区。合并遇到冲突时候，使用这个命令进行将文件标记为合并成功。</p><p><code>git commit -m &quot;message&quot;</code>: 提交改动，将改动从缓冲区提交到<code>HEAD</code>，但是不是远程仓库。</p><p><code>git status</code>: 查看仓库当前状态。</p><p><code>git diff &lt;filename&gt;</code>: 查看当前对文件的修改内容（未提交到缓冲区）。</p><p><code>git log</code>: 获取当前提交ID。显示从最近到最远的提交日志。<code>--pretty=oneline</code> 参数可以简化输出。<code>--graph</code> 可以查看分支合并图。</p><h4 id="Git-时光穿梭"><a href="#Git-时光穿梭" class="headerlink" title="Git 时光穿梭"></a>Git 时光穿梭</h4><p><code>git reset --hard HEAD^</code>: <code>HEAD</code>表示最新版本，<code>HEAD~100</code>表示之前100个版本，<code>HEAD^</code>表示上一个版本，选择回退到那个版本。</p><p><code>git reflog</code>: 记录每一次的<code>git</code>命令，选择去未来的那个版本。</p><p><code>git checkout -- &lt;filename&gt;</code>: 将工作区的修改撤销，恢复到缓冲区或者是版本库。</p><p><code>git reset HEAD &lt;filename&gt;</code>： 将暂存区的修改撤销，重新放回工作区。</p><p><code>rm &lt;filename&gt; &amp;&amp; git rm &lt;filename&gt;</code>：删除文件。</p><h4 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h4><p><code>git remote -v</code>: 显示远程仓库，</p><p><code>git remote add origin &lt;server&gt;</code>: 将仓库连接到某个远程服务器。</p><p><code>git push origin &lt;master&gt;</code>: 将改动提交到了远程仓库中，可以切换为想要推送的不同分支。 （可以使用<code>-u</code>参数对于本地仓库和远程仓库进行关联）</p><p><code>git pull</code>: 将工作目录的代码获取并合并远程的改动。</p><p><code>git push</code>出现冲突的时候：需要先<code>git pull</code> 把最新的提交从分支中扒下来，然后在本地合并，解决冲突，在推送。</p><p><code>git branch --set-upstream-to=origin/dev dev</code>: 将本地特定分支和远程<code>dev</code>分支进行绑定。</p><p><code>git rebase</code>: 将分叉的提交历史变成一条直线</p><h4 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h4><p><code>git branch</code>: 查看当前分支。</p><p><code>git checkout -b feature_x</code>: 新建一个叫做<code>feature_x</code>的分支，并且切换过去。<br>        <code>git branch feature_x  &amp;&amp; git checkout feature_x</code></p><p><code>git checkout master</code>: 切换到主分支。</p><p><code>git branch -d feature_x</code>: 删除新建的分支。</p><p><code>git branch -D feature_x</code>: 强制删除未合并分支。</p><p><code>git merge &lt;branch&gt;</code>: 合并其他分支到当前分支， 使用<code>--no-ff</code>参数来 禁用<code>Fast Forward</code>模式并追加<code>-m commit</code>添加Commit。</p><p><code>git diff &lt;source_branch&gt; &lt;feature_branch&gt;</code>: 进行两个分支的比较。</p><p><code>git stach</code>: 将当前工作现场保存下来，等之后恢复现场后可以继续工作。</p><p><code>git stash list</code>: 将工作现场列表显示出来。</p><p><code>git stash pop</code> = <code>git stash apply &amp;&amp; git stash pop</code>: 处理之前的工作现场。</p><h4 id="Git-标签管理"><a href="#Git-标签管理" class="headerlink" title="Git 标签管理"></a>Git 标签管理</h4><blockquote><p>Git 的标签就是一个和commit 挂钩，并且有意义的名字。</p></blockquote><p><code>git tag</code>: 查看所有标签。</p><p><code>git tag -a &lt;1.0.0&gt; &lt;commit_id&gt; -m &lt;comment&gt;</code>: 给某次提交打标签。</p><p><code>git tag -d v0.1</code>:  删除本地标签。</p><p><code>git push origin &lt;tagname&gt;</code>: 将标签提交到远程。</p><p><code>git push origin --tags</code>: 将全部标签提交到远程。</p><p><code>git push origin:refs/tags/&lt;tagname&gt;</code>:  删除远程标签</p><p><code>git show &lt;tagname&gt;</code>: 查看标签信息。</p><p><code>git fetch origin &amp;&amp; git reset --hard origin/master</code>： 放弃当前修改，从服务器上获取最新修改，并将本地分支指向它。</p><h4 id="Git-其他"><a href="#Git-其他" class="headerlink" title="Git 其他"></a>Git 其他</h4><p><code>.gitignore</code>文件</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的Git教程</a></li><li><a href="https://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">Git 简明指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/08/08/git/git.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java &amp;&amp; Python 算法面试常用类以及方法总结</title>
    <link href="http://yoursite.com/2019/07/30/Java-data-structure/"/>
    <id>http://yoursite.com/2019/07/30/Java-data-structure/</id>
    <published>2019-07-30T19:58:00.000Z</published>
    <updated>2019-08-14T22:52:31.657Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/30/Java-data-structure/datastructure.png" alt></p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>逻辑结构上： 包括集合，线性结构，非线性结构。</li><li>存储结构： 顺序存储，链式存储，索引存储，散列存储。</li></ol><h3 id="Java-常见数据结构"><a href="#Java-常见数据结构" class="headerlink" title="Java 常见数据结构"></a>Java 常见数据结构</h3><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/07/30/Java-data-structure/datastructure.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java 知识点总结</title>
    <link href="http://yoursite.com/2019/07/26/Java/"/>
    <id>http://yoursite.com/2019/07/26/Java/</id>
    <published>2019-07-26T22:15:12.000Z</published>
    <updated>2019-07-29T23:05:26.170Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/26/Java/Java.png" alt></p><a id="more"></a><blockquote><p>这篇是参考Java快速教程之后的一份学习笔记</p></blockquote><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="Hello-World-到面向对象"><a href="#Hello-World-到面向对象" class="headerlink" title="Hello World 到面向对象"></a>Hello World 到面向对象</h5><ul><li>类(class)：上面程序定义了一个类HelloWorld，该类的名字与.java文件的名字相同。</li><li>方法(method)：类的内部定义了该类的一个方法main。</li><li>语句(statement)：真正的“打印”功能由一个语句实现，即: System.out.println(“Hello World!”);</li><li>使用<code>javac</code>编译，使用<code>java</code>运行</li><li>Java不同变量类型在程序中的内存分布</li></ul><table><thead><tr><th align="center">类型</th><th align="center">存储大小</th><th align="center">例值</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1byte</td><td align="center">3</td><td align="center">字节</td></tr><tr><td align="center">int</td><td align="center">4bytes</td><td align="center">3</td><td align="center">整数</td></tr><tr><td align="center">short</td><td align="center">2bytes</td><td align="center">3</td><td align="center">短整数</td></tr><tr><td align="center">long</td><td align="center">8bytes</td><td align="center">3</td><td align="center">长整数</td></tr><tr><td align="center">float</td><td align="center">4bytes</td><td align="center">1.2</td><td align="center">单精度浮点数</td></tr><tr><td align="center">double</td><td align="center">8bytes</td><td align="center">1.2</td><td align="center">双精度浮点数</td></tr><tr><td align="center">char</td><td align="center">2bytes</td><td align="center">‘a’</td><td align="center">字符</td></tr><tr><td align="center">boolean</td><td align="center">1bit</td><td align="center">true</td><td align="center">布尔值</td></tr></tbody></table><ul><li>Java 数组声明和定义<ul><li>声明：<code>int[] a;</code></li><li>声明的同时使用<code>new</code>来创建数组所需空间：<code>int[] a = new int[100];</code></li><li>声明创建同时指定元素内容：<code>int[] a = new int[]{1,3,5,7,9};</code></li></ul></li><li>表达式<ul><li>数学表达式： +,-,*,/,%</li><li>关系表达式：&gt;,&gt;=,==,&lt;=,&lt;,!=</li><li>布尔表达式：&amp;&amp;,||,!</li><li>位运算：&amp;,|,^,~,&lt;&lt;,&gt;&gt;</li><li>双目表达式：condition? X1:X2</li></ul></li><li>控制结构<ul><li>选择结构<ul><li>if else</li><li>switch</li></ul></li><li>循环结构：<ul><li>while </li><li>do{} while()</li><li>for(){}</li></ul></li><li>break</li><li>continue</li></ul></li></ul><h5 id="方法和数据对象"><a href="#方法和数据对象" class="headerlink" title="方法和数据对象"></a>方法和数据对象</h5><ul><li>Java 使用return来返回值</li><li>this 指代的是对象本身</li><li>成员方法可以添加参数列表</li><li>使用 this.method() 调用同一对象的其他方法</li><li>显式初始化：声明对象时候，对于对象进行赋值</li></ul><h5 id="构造器以及重载"><a href="#构造器以及重载" class="headerlink" title="构造器以及重载"></a>构造器以及重载</h5><ul><li>构造器定义函数值： 类似于C语言中的构造函数</li><li>构建方法 &gt; 显式初始值 &gt; 默认初始值</li><li>Java根据方法名和参数列表决定要调用的方法，叫做方法重载</li></ul><h5 id="封装和接口"><a href="#封装和接口" class="headerlink" title="封装和接口"></a>封装和接口</h5><ul><li>三种不同的封装方法<ul><li>public</li><li>private</li><li>protected： 标记为protected的成员变量在该类和该类的衍生类中可见，但不能被外界访问。</li></ul></li><li>interface 接口<ul><li>interface 可以定义接口</li><li>implements 可以实现接口</li><li>可以实现一个类 实现多个接口</li></ul></li><li>has-a 关系 一个对象可以拥有另一个对象 (手电筒有电池)</li><li>package : 将Java程序代码进行打包，使用包进行访问</li><li>JVM，实现程序的可移植性</li><li>extends 继承<ul><li>新类称之为衍生类</li><li>同名同参数方法会存在方法覆盖</li><li>使用super访问父层的方法</li><li>基类对象先被创建和进行初始化，结束之后，开始构建衍生层(衍生层对象进行创建和初始化)</li></ul></li></ul><h5 id="类数据和类方法"><a href="#类数据和类方法" class="headerlink" title="类数据和类方法"></a>类数据和类方法</h5><ul><li>类数据对象： 所有成员进行共享的变量 使用关键字 static</li><li>类方法：操作类对象的方法使用关键字static, 使用这个关键字的方法不能正常操作属于对象的数据和方法</li><li>对象方法可以访问类数据</li><li>final 关键字：这个数据 / 类 / 方法不能被改变了, private 方法默认为final方法</li></ul><h5 id="接口继承和抽象类"><a href="#接口继承和抽象类" class="headerlink" title="接口继承和抽象类"></a>接口继承和抽象类</h5><ul><li>接口的继承： 和类的继承类似， 可以添加设计更多的方法，不同点，可以实现多重继承</li><li>抽象类：只提供类的原型，不提供类的具体实现。</li></ul><h5 id="Java-对象引用"><a href="#Java-对象引用" class="headerlink" title="Java 对象引用"></a>Java 对象引用</h5><ul><li>new 在内存中为对象开辟了空间，在内存的堆上开辟了空间。</li><li>对象引用存储在内存的栈中</li><li>当我们将一个引用赋值给另一个引用的时候，我们实际上复制的是对象的地址，两个引用将操作同一个对象。当程序通过一个引用修改了对象之后，通过其他引用课也可以看到该修改。</li><li>垃圾回收机制：当一个对象没有引用指向的时候，这个对象就会被清空。</li><li>Java 参数传递：Java的参数传递为值传递。当我们传递一个参数时，方法将获得该参数的一个拷贝。<ul><li>基本对象的参数传递：传递的是值的拷贝，Java方法不会影响到值，形式变量和实际变量。</li><li>引用值的参数传递： 传递的是对象的地址，Java方法会直接影响到对象。</li></ul></li></ul><h5 id="类型转换和多态"><a href="#类型转换和多态" class="headerlink" title="类型转换和多态"></a>类型转换和多态</h5><ul><li>类型检查</li><li>基本类型检查： 收缩类型变换（强制类型转换），宽松变换(自动进行)</li><li>Upcast 和多态：一个衍生类可以转换为其基类引用</li><li>一个衍生类对象可以当做一个基类对象使用</li><li>所有对象都有一个共同的继承祖先，<code>Object</code>类</li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><h5 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h5><ul><li><p>创建字符串 不需要<code>new</code>关键字</p></li><li><p>Java String 类别中的常用方法</p><table><thead><tr><th>方法</th><th>效果</th></tr></thead><tbody><tr><td>s.length()</td><td>返回字符串s的长度</td></tr><tr><td>s.charAt()</td><td>返回字符串中下标为2的字符</td></tr><tr><td>s.substring(0,4)</td><td>返回s字符串中下标0-4的子字符串</td></tr><tr><td>s.indexOf(“Hello”)</td><td>返回子字符串”Hello“的下标</td></tr><tr><td>s.startsWith(“ “)</td><td>返回s是否以空格开始</td></tr><tr><td>s.endsWith(“oo”)</td><td>判断s是否以”oo”结束</td></tr><tr><td>s.equals(“Good World!”)</td><td>判断s是否等于”Good World!”， ==只能判断字符串是否保存在同一位置。需要使用equals()判断字符串的内容是否相同。</td></tr><tr><td>s.compareTo(“Hello Nerd!”)</td><td>比较s字符串与”Hello Nerd!”在词典中的顺序，返回一个整数，如果&lt;0，说明s在”Hello Nerd!”之前；如果&gt;0，说明s在”Hello Nerd!”之后；如果==0，说明s与”Hello Nerd!”相等。</td></tr><tr><td>s.trim()</td><td>去掉s前后的空格字符串，并返回新的字符串</td></tr><tr><td>s.toUpperCase()</td><td>将s转换为大写字母，并返回新的字符串</td></tr><tr><td>s.toLowerCase()</td><td>将s转换为小写字母，并返回新的字符串</td></tr><tr><td>s.replace(“World”, “Universe”)</td><td>将”World”替换为”Universe”，并返回新的字符串</td></tr></tbody></table></li><li><p>String 类型对象是不可变对象</p></li></ul><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><ul><li><code>try</code>, <code>catch</code>, <code>finally</code> 以及其随后的代码段来组成，<code>finally</code> 不是必须的</li><li><code>try</code>后面的程序块包含了针对该异常类型所要进行的操作。<code>try</code>所监视的程序块可能抛出不止一种类型的异常，所以一个异常处理器可以有多个<code>catch</code>模块。<code>finally</code>后面的程序块是无论是否发生异常，都要执行的程序。</li><li>异常都来自与<code>Throwable</code>类，一个<code>Throwable</code>类对象可以抛出，异常分为<code>unchecked</code> 异常和<code>checked</code>异常。</li><li><code>Error</code>是指<code>Java</code>的内部错误或者是资源耗尽等错误，需要直接退出程序。</li><li><code>Exception</code>里面一个衍生类<code>RuntimeException</code> 都是程序自身的问题组成的。</li><li><code>checked</code> 异常，是由编程与环境</li><li>可以自己新建类，在程序中抛出异常</li><li>可以自定义异常，使用继承的方式，需要小心选择所继承的基类。</li></ul><h5 id="运行时类别识别（RTTI）"><a href="#运行时类别识别（RTTI）" class="headerlink" title="运行时类别识别（RTTI）"></a>运行时类别识别（RTTI）</h5><ul><li><code>Class</code>类：对类的抽象和集合。当我们调用对象的<code>getClass()</code>的时候，就会得到其对应<code>Class</code>对象的引用</li><li><code>Class</code>类方法<ul><li><code>getName()</code> 返回类的名字</li><li><code>getPackage()</code>返回类所在的包</li><li><code>getFields()</code>返回所有的public数据成员</li><li><code>getMethods()</code>返回所有的public方法</li></ul></li></ul><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><ul><li>多线程是计算机实现多任务并行处理的一种方式</li><li>单核CPU会在不同的任务之间做切换，这是操作系统分时复用的机制</li><li>多个线程可以并存于同一个进程空间。在JVM的一个进程空间中，一个栈(stack)代表了方法调用的次序。对于多线程来说，进程空间中需要有多个栈，以记录不同线程的调用次序。多个栈互不影响，但所有的线程将共享堆(heap)中的对象。</li><li><code>Thread</code>基类的构造方法可以使用一个字符串作为参数，该字符串是该线程的名字，并使用<code>getName()</code>返回。<ul><li>我们调用线程对象的<code>start()</code> 方法启动线程</li><li><code>join(Thread tr)</code>： 等待线程tr完成</li><li><code>setDaemon()</code>: 设置当前线程为后台daemon</li></ul></li><li>另一种实现多线程的方法是实现<code>Runable</code>接口，并提供<code>run()</code>方法</li><li>Synchronized: 进程之间的同步，防止出现超票的情况<ul><li>我们将共享的资源置于一个对象中</li><li>对于共享资源的操作，放在<code>synchronized</code>方法中</li></ul></li></ul><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><ul><li><p>数组</p><ul><li><p>在说明类型时，在类型说明后面增加一个<code>[]</code>，来说明是一个数组。</p></li><li><p>使用<code>new</code>创建容器时，需要说明数组的大小。我们可以使用 数组名[下标] 的方式来调用某个元素。</p></li><li><p>我们可以逐个的初始化数组的元素，也可以在声明的同时使用<code>{}</code>初始化数组。</p></li><li><p>使用<code>System.arraycopy()</code>方法来有效的复制数组</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(aFrom, <span class="number">1</span>, aTo, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//aFrom为想要复制出去的数组，aTo为想要复制到的数组，1为aFrom的想要复制出去的元素起始位置，0为aTo中想要存储复制来元素的起始位置，3为所要复制的元素总数。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Collection</p><ul><li><code>List</code>  表<ul><li>容器的引用为List类型， 但是容器的实施类型为<code>ArrayList</code>类型。</li><li>将接口和实施做分离</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">add();<span class="comment">//方法加入新的元素</span></span><br><span class="line">get();<span class="comment">//方法可以获取容器中的元素，传递一个整数下标作为参数</span></span><br><span class="line">remove();<span class="comment">//方法可以删除容器中的元素，传递一个整数下标作为参数。(有另一个remove()，传递元素自身作为参数)</span></span><br><span class="line">size();<span class="comment">//方法用来返回容器中元素的总数</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Set</code> 集合</p><ul><li>集合中不允许有等值的元素</li><li>集合的元素没有顺序</li></ul></li><li><p><code>Map</code> 键值对的集合</p><p><img src="/2019/07/26/Java/Java-1.png" alt="Java-1"></p></li><li><p><code>Collection</code></p><ul><li><p>主要方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object o)</span></span>;<span class="comment">//添加对象到集合</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//将指定 collection 中的所有元素都添加到此 collection 中（可选操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//删除集合中所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;<span class="comment">//删除指定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//返回当前集合中元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;<span class="comment">//查找集合中是否有指定的对象</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span></span>;<span class="comment">//查找集合中是否有集合c中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断集合是否为空</span></span><br><span class="line"><span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">//返回一个迭代器</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>iterator</code> 接口：不论<code>Collection</code> 的实际类型是什么，都支持一个<code>iterator()</code>的方法，该方法返回一个迭代子，使用该迭代子可以逐一访问<code>Collection</code>里面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; <span class="comment">//如果仍有元素可以迭代，则返回True</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>; <span class="comment">//返回下一个迭代的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>; <span class="comment">//将迭代器指向的集合中，移除迭代器返回的最后一个元素</span></span><br></pre></td></tr></table></figure></li><li><p><code>List</code> 接口： 有序的<code>Collection</code>，使用这个接口可以精确的控制每个元素插入的位置，用户可以使用索引（下标的方式）对于对象进行访问。</p><ul><li><code>LinkedList</code> 类：允许<code>null</code>元素，提供额外的<code>get</code>,<code>remove</code>,<code>insert</code> 方法，并不是线程安全的，注意它没有同步方法，需要自己新建。</li><li><code>ArrayList</code>类：实现了一个大小可变的数组，允许<code>null</code>元素，没有同步方法。</li><li>快速添加删除，使用<code>LinkedList</code>，需要快速随机访问元素，使用<code>ArrayList</code>类</li><li><code>Vector</code>类：类似于<code>ArrayList</code>，但是存在的同步方法，是线程安全的，使用<code>Iterator</code>进行遍历操作时候，不同线程对于同一个对象操作会产生异常。`</li><li><code>Stack</code>类：继承自<code>Vector</code>, 实现了一个后进先出的栈，提供5个额外的方法使得<code>Vector</code>能够当做栈来使用，<code>push</code>, <code>pop</code>,<code>peek</code>, <code>empty</code>,<code>search</code>，刚开始创建的时候是空栈。</li></ul></li><li><p><code>Set</code>接口： 不包含重复元素的<code>Collection</code></p><ul><li><code>HashSet</code>: 方法有<code>add()</code>,<code>remove(元素)</code> ，旗下还有实现类<code>LinkedHashSet</code></li><li><code>TreeSet</code>: 是<code>Set</code>的一种变体，可以实现按照树型进行插入，实现元素的排序（从小到大）</li></ul></li><li><p><code>Map</code>接口:  没有实现<code>Collection</code>类，提供从key到value的一种映射。</p><ul><li><p><code>Map</code>接口需要实现的方法有：</p><p>put/putAll/remove/clear  增加删除     </p><p>get/values 获取值</p><p>containKey/containValue 判断</p><p>entrySet/keySet 获取迭代</p><p>equals/hashcode 比较</p></li><li><p><code>HashMap</code> 类: 非进程同步的</p></li><li><p><code>HashTable</code>类：进程同步的</p></li><li><p><code>TreeMap</code>类：<code>Map</code>数据是根据<code>key</code>来进行排序的</p></li></ul></li></ul></li></ul><h5 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h5><ul><li><p>内部类</p><ul><li><p>Java 允许我们在一个类中嵌套另一个类， 在类的内部定义一个新类，这个类称为内部类</p></li><li><p>内部类是被认为是外部对象的一个成员，在定义内部类的时候，同样有访问权限控制（public, private, protected）</p></li><li><p>内部类的默认访问权限是包访问权限，我们可以在外部测试类中访问到对象的内部类，并使用该内部类创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human.Cup soloCup = me.new Cup();</span><br></pre></td></tr></table></figure><p>在创建对象的时候，要注意必须基于一个外部类，并使用这个外部类对象来创建<code>Cup</code>对象。</p></li></ul></li><li><p>闭包</p><ul><li>内部类对象必须依附于某个外部类对象，与此同时，内部类对象也可以访问到它所依附的外部类对象的成员（即便是private成员）。从另一个角度来讲，内部类对象附带有创建对象时的环境信息。</li></ul></li><li><p>嵌套static类</p><ul><li>我们可以定义嵌套的static类，对象不需要依附于外部类的某个对象。相应的，这个嵌套类也无法调用外部对象的方法，也无法读取或者修改外部对象的数据。效果上看，就是扩展了类的命名空间。</li></ul></li></ul><h5 id="GUI-图形界面以及事件响应"><a href="#GUI-图形界面以及事件响应" class="headerlink" title="GUI 图形界面以及事件响应"></a>GUI 图形界面以及事件响应</h5><ul><li>Java GUI 功能主要集中在awt和swing中。awt是GUI的底层包。</li><li>Java Layout 布局方式：Java 里面存在着不同的布局方式。<a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank" rel="noopener">Java布局方式</a></li><li>元素，事件，监听器： 通过监听器，可以将事件绑定在图形元素上面 <code>ActionListener</code>, <code>ActionEvent class</code>  </li></ul><h5 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h5><ul><li><p>Java 是在JVM所虚拟出来的内存环境中运行的。</p></li><li><p>内存分为栈<code>stack</code>和堆<code>heap</code> 两个部分</p></li><li><p>栈</p><ul><li>记录了线程的方法调用，每个线程有一个栈</li><li>如果有新的方法调用，那么栈会增长</li><li>栈的存储单元为帧（frame）</li><li>栈中保存基本变量类型的变量值，以及对象的引用，引用指向堆</li><li>调用结束之后，栈会被释放</li></ul></li><li><p>堆</p><ul><li>堆的空间不会随着方法调用结束而清空，因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。</li></ul></li><li><p>垃圾回收 Garbage Collection (GC)</p><ul><li><p>垃圾回收负责释放不可到达的对象（即没有引用的指向的对象）</p></li><li><p>早期垃圾回收采用引用计数机制，但是存在循环引用不可处理的问题</p></li><li><p>“mark and sweep”： 这种机制下，每个对象将有标记信息，用于表示该对象是否可到达。当垃圾回收启动时，Java程序暂停运行。JVM从根出发，找到所有的可到达对象，并标记(mark)。随后，JVM需要扫描整个堆，找到剩余的对象，并清空这些对象所占据的内存。</p></li><li><p>“copy and sweep”。这种机制下，堆被分为两个区域。对象总存活于两个区域中的一个。当垃圾回收启动时，Java程序暂停运行。JVM从根出发，找到可到达对象，将可到达对象复制到空白区域中并紧密排列，修改由于对象移动所造成的引用地址的变化。最后，直接清空对象原先存活的整个区域，使其成为新的空白区域。</p></li><li><p>这两种机制， “mark and sweep”, “copy and sweep” 都是通过分代回收来进行回收的。</p></li><li><p>每个对象会记录它的世代信息，世代就是指对该对象所经历的垃圾分类回收的次数，世代越久远的对象，在内存中存活的时间就越长。</p></li><li><p><img src="/2019/07/26/Java/generation.png" alt="generation"></p><p>在上图中，堆分为三代，其中永久世代不会被垃圾回收，里面存储的是Class和类相关的信息。年轻世代和成熟世代需要进行垃圾回收。年轻世代需要分为三个区域，第一个区域叫做伊甸，新生对象将存在于这个区域。from, to: 这两个区域大小相等，相当于copy and sweep中的两个区域。当新建对象无法放入eden区时，将出发minor collection。JVM采用copy and sweep的策略，将eden区与from区的可到达对象复制到to区。经过一次垃圾回收，eden区和from区清空，to区中则紧密的存放着存活对象。随后，from区成为新的to区， to区成为新的from区。如果进行minor collection的时候，发现to区放不下，则将部分对象放入成熟世代。另一方面，即使to区没有满，JVM依然会移动世代足够久远的对象到成熟世代。</p></li></ul></li></ul><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://www.cnblogs.com/vamei/archive/2013/03/31/2991531.html" target="_blank" rel="noopener">Java 快速教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/07/26/Java/Java.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network 知识点总结</title>
    <link href="http://yoursite.com/2019/07/23/Computer_Network/"/>
    <id>http://yoursite.com/2019/07/23/Computer_Network/</id>
    <published>2019-07-24T03:00:55.000Z</published>
    <updated>2019-07-27T00:22:39.402Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/23/Computer_Network/Computer_Network.png" alt></p><a id="more"></a><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ul><li>计算机中的二进制数<ul><li>原码：使用最高位表示符号，后面表示数据大小</li><li>补码：正数和原码相同，负数为去除符号位的各位取反，末尾加一得到。（类似于计算机计算中的取模）</li><li>反码：原码各位（除了符号位）取反</li><li>移码：补码，符号位取反</li></ul></li><li>计算机网络定义： 将不同地理位置，具有独立功能的多台计算机及网络设备通过通信线路（包括传输介质和网络设备）连接起来，在网络操作系统，网络管理软件及网络通信协议的共同管理和协调下实现资源共享和信息传递的计算机系统</li><li>计算机网络的基本组成<ul><li>硬件系统：计算机设备，传输介质，网络设备。</li><li>软件系统：操作系统，网络通信协议</li></ul></li></ul><h5 id="互联网体系结构"><a href="#互联网体系结构" class="headerlink" title="互联网体系结构"></a>互联网体系结构</h5><ul><li><p><img src="/2019/07/23/Computer_Network/network_structure.png" alt></p><p><img src="/2019/07/23/Computer_Network/network_function.png" alt></p></li></ul><ul><li><p>五层体系结构（转载自<a href="https://www.cnblogs.com/vamei/archive/2012/11/24/2773967.html" target="_blank" rel="noopener">https://www.cnblogs.com/vamei/archive/2012/11/24/2773967.html</a>）</p><ul><li><p>物理层： 是指光纤、电缆或者电磁波等真实存在的物理媒介。这些媒介可以传送物理信号，比如亮度、电压或者振幅。对于数字应用来说，我们只需要两种物理信号来分别表示0和1，比如用高电压表示1，低电压表示0，就构成了简单的物理层协议。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为0/1序列。</p></li><li><p>连接层：信息以帧(frame)为单位传输。所谓的帧，是一段有限的0/1序列。连接层协议的功能就是识别0/1序列中所包含的帧。比如说，根据一定的0/1组合识别出帧的起始和结束。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。当然，帧中最重要的最重要是所要传输的数据 (payload)。 这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(Type)信息。连接层协议不关心数据中到底包含什么。帧就像是一个信封，把数据包裹起来。数据帧中包括，SRC, DST, 数据，纠错码。Ethernet 以太网和WiFi 是现行的常见的连接层协议。</p></li><li><p>网络层：不同的社区之间该如何通信呢？ 换句话说，如何让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人”。这个“中间人”必须有以下功能: 1. 能从物理层上在两个网络的接收和发送0/1序列，2. 能同时理解两种网络的帧格式。路由器(router)就是为此而产生的“翻译”。一个路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。所以路由器就像是在两个社区都有分支的邮局一个社区的邮差将信送到本社区的邮局分支，而邮局会通过自己在另一个地区的分支将信转交给另一个社区的邮差手中，并由另一个社区的邮差最终送到目的地。</p></li><li><p>传输层：上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求(参看<a href="http://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html" target="_blank" rel="noopener">Linux进程基础</a>和<a href="http://www.cnblogs.com/vamei/archive/2012/10/10/2715398.html" target="_blank" rel="noopener">Linux进程间通信</a>)。这就好像一所房子里住了好几个人(进程)，如何让信精确的送到某个人手里呢？遵照之前相同的逻辑，我们需要在信纸上写上新的信息，比如收信人的姓名，才可能让信送到。所以，传输层就是在信纸的空白上写上新的“收信人”信息。每一所房子会配备一个管理员(传输层协议)。管理员从邮差手中接过信，会根据“收信人”，将信送给房子中的某个人。 传输层协议，比如TCP和UDP，使用端口号(port number)来识别收信人(某个进程)。在写信的时候，我们写上目的地的端口。当信到达目的地的管理员手中，他会根据传输层协议，识别端口号，将信送给不同的人。TCP和UDP协议是两种不同的传输层协议。UDP协议类似于我们的信件交流过程。TCP协议则好像两个情人间的频繁通信。一个小情人要表达的感情太多，以致于连续写了好几封信。而另一方必须将这些信按顺序排列起来，才能看明白全部的意思。TCP协议还有控制网络交通等功能。</p></li><li><p>应用层：通过上面的几层协议，我们已经可以在任意两个人(进程)之间进行通信。然而每个人实际上从事的是不同的行业。有的人是律师，有的人外交官。比如说律师之间的通信，会用严格的律师术语，以免产生纠纷。再比如外交官之间的通信，必须符合一定的外交格式，以免发生外交误会。再比如间谍通过暗号来传递加密信息。应用层协议是对信件内容进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。</p></li></ul><p>整个通信过程如下:</p><p>WiFi上的计算机1-&gt;路由WiFi接口-&gt;  路由以太网接口-&gt; 以太网上的计算机2</p><p>(蓝色表示WiFi网络，绿色表示以太网络)</p><p>在连接层，我们的一个帧中只能记录SRC和DST两个地址。而上面的过程需要经过四个地址 (计算机1，WiFi接口，以太网接口，计算机2)。显然，仅仅靠连接层协议无法满足我们的需要。由于连接层协议开发在先，我们无法改动连接层协议，只能在连接层的数据(payload)，也就是信纸内部下功夫了。IP协议应运而生。</p><p>计算机1，路由器和计算机2都要懂得IP协议。当计算机1写信的时候，会在信纸的开头写上这封信的出发地址和最终到达地址 (而不是在信封上)，而在信封上写上要送往邮局。WiFi网的邮差将信送往邮局。在邮局，信被打开，邮局工作人员看到最终地址，于是将信包装在一个新的信封中，写上出发地为邮局，到达地为计算机2，并交给以太网的邮差，由以太网的邮差送往计算机2。</p><p>所以邮局要求，信纸上写的地址必须是一个符合官方规定的“邮编”，也就是IP地址。这个地址为世界上的每一个房子编号(邮编)。当信件送到邮局的时候，邮局根据邮编，就能查到对应的地址描述，从而能顺利改写信封上的信息。</p><p>每个邮局一般连接多个社区，而一个社区也可以有多个邮局，分别通往不同的社区。有时候一封信要通过多个邮局转交，才能最终到达目的地，这个过程叫做route。邮局将分离的局域网络连接成了internet，并最终构成了覆盖全球的互联网。</p></li></ul><h5 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h5><ul><li><p>连接层协议：Ethernet 以太网协议和WiFi协议</p><ul><li>Ethernet 以太网协议</li></ul><ul><li>头部（preamble，SFD 起始信号，DST 目的地，SRC 发出地，Type 类型）<ul><li>数据 （IP包）</li></ul></li><li>尾部（FCS校验和（使用CRC校验））<ul><li>集线器（Hub）：广播式传播，不允许冲突，需要添加冲突处理算法。</li></ul></li><li>交换机（Switch）:只向特定的网络接口中传播数据。</li></ul><ul><li>WiFi 协议(802.11协议)</li></ul></li><li><p>网络层协议：</p><ul><li>网卡： 网卡（Network Interface Card) 是计算机中的一个硬件，在接收到了网络信息之后，将信息交给计算机，当计算机需要发送信息的时候，也通过网卡发送。</li><li>路由器：就是配有多个网卡的硬件，帮助网卡接入不同的网络中。</li><li>IP协议： 不可靠。不能保证按序到达。<ul><li>IPv4 =&gt; IPv6: 地址耗尽的危机</li><li>Version, Source Address, Destination Address: IP 协议版本，出发地IP和目的地IP</li><li>Time to live =&gt; Hop Limit : 表示一个IP包的最大存活时间</li><li>Type of Service =&gt; Traffic Class: 为包分优先级， 后被分为Differentiated Service Field (DS, 前6位)和 Explicit Congestion Notification (ECN, 后2位)</li><li>Protocol =&gt; Next Header: 包中所包含的协议是什么</li><li>IHL 记录头部长度，Total Length =&gt; Payload Length 表示IPv6数据部分的长度。</li><li>Header Checksum：校验IP头部信息。</li><li>Identification, flags和fragment offset: 为包的碎片化准备，包传播路径上面有MTU(最大传输单元)</li><li>Flow Label (IPv6 中新增)： 提醒路由器来重复之前的接力路径，这样IP包可以保持出发的顺序。</li></ul></li><li>RIP 协议(Routing Information Protocol)：通过距离来决定routing table. 通常在一个自治系统中使用。</li><li>BGP 协议(Boarder Gateway Protocol)：不同的 AS 相互沟通的协议。</li><li>为了应对地址不够用的危机，使用CIDR无类域间路由进行网络扩展，相当于每个IP多了一个配套的子网掩码。</li><li>NAT协议<ul><li>基础NAT协议</li><li>NATP协议</li></ul></li></ul></li><li><p>介于网络层和传输层之间的协议：ICMP 协议， 主要作用是传输网络诊断信息。</p><ul><li><p>ARP协议用于发现周边的IP地址和MAC地址的对应。然而，ARP协议只用于IPv4，IPv6并不使用ARP协议。IPv6包通过邻居探索(ND, Neighbor Discovery)来实现ARP的功能。ND的工作方式与ARP类似，但它基于ICMP协议。ICMP包有Neighbor Solicitation和Neighbor Advertisement类型。这两个类型分别对应ARP协议的询问和回复信息。</p></li><li><p>传递错误信息和咨询信息。ICMP协议是基于IP协议的。是实现ping命令和traceroute命令的基础。</p></li><li><p>常见的ICMP包类型</p><ul><li>回音：Echo-询问类型包，Echo-回答类型包</li><li>源头冷却：提醒主机减慢发包速度。</li><li>目的地无法到达：可能不存在合适的路由或者是相对应接口没有开启。</li><li>超时：TTL减为0的时候，发生的错误就是超时错误。</li><li>重定向: 当一个路由器收到了一个IP包，对照其routing table,发现自己不应该收到该IP包，它会向主机发送重新定向类型的ICMP, 提醒出发主机修改自己的routing table.</li></ul></li></ul></li><li><p>传输层协议</p><ul><li><p>UDP协议： 和IP协议非常相似，不可靠的，以数据包形式传输。</p><ul><li>UDP分为头部，和数据部分两个部分。</li><li>UDP头部包括source port，destination port，Length 以及 Checksum 四个部分。</li><li>可以调用操作系统中的API，来构建socket。Socket是操作系统提供的一个编程接口，它用来代表某个网络通信。</li></ul></li><li><p>TCP协议：传输层的流协议。可靠的协议。双向的。</p><ul><li><p>滑动窗口协议代替单纯的stop and wait 协议：传输(Seq),等待(Ack)</p></li><li><p>TCP需要两个IP，两个端口确定谁和谁在说话。同一个端口上可能有很多个连接。 </p></li></ul></li></ul></li><li><p>应用层协议</p><ul><li>基于TCP：FTP(文件传输协议，端口21)，Telnet(远程登录，支持BBS，端口23)， SMTP(简单邮件传输协议，端口25)，POP3(用于接受邮件的协议，端口110)，HTTP(超文本传输协议)</li><li>基于UDP：DNS(域名解析协议，端口53)， SNMP(简单网络管理协议，端口161)，TFTP(简单文件传输协议，端口69)</li></ul></li></ul><h5 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h5><ul><li><p>TCP头部</p><p><img src="/2019/07/23/Computer_Network/tcpheader.png" alt></p></li><li><p>TCP 连接</p><ul><li><p>每个TCP片段都有自己的序号，ACK是一位，只有ACK设定的时候，回复号才生效，许多ACK回复的时候，是附着在其双向的连接中，也可以附着在SYN和FIN片段中。</p></li><li><p>TCP三次握手</p><p>ISN 交换 (Initial Sequence Number)</p><p><img src="/2019/07/23/Computer_Network/tcp_open.png" alt></p><p>青色为纯粹的ACK片段。整个过程的本质是双方互发含有自己的ISN的SYN片段。根据TCP传输的规则，接收到ISN的一方需要回复ACK，所以共计四片信息在建立连接过程中传输。之所以是三次握手 (而不是四次)，是因为server将发送SYN和回复ACK合并到一个TCP片段中。我们以client方为例。client知道自己的ISN(也就是ISN(c))。建立连接之后，它也知道了对方的ISN(s)。此后，如果需要发送文本流片段，则编号为ISN(c) + 1, ISN(c) + 2 …。如果接收文本流片段，则期待接收ISN(s) + 1, ISN(s) + 2 …。连接建立之后，连接的双方就可以按照TCP传输的方式相互发送文本流了。</p></li><li><p>TCP 四次挥手 连接终结</p><p><img src="/2019/07/23/Computer_Network/tcp_close.png" alt="image-20190723154819723"></p><p>一个连接建立之后，连接两端的进程可以利用该连接进行通信。当连接的一方觉得“我讲完了”，它可以终结连接中发送到对方方向的通信。连接最终通过四次握手(four-way handshaking)的方式终结，连接终结使用的是特殊片段FIN(FIN位为1的片段)。</p><p>我们可以看到，连接终结的过程中，连接双方也交换了四片信息(两个FIN和两个ACK)。在终结连接的过程中，TCP并没有合并FIN与ACK片段。原因是TCP连接允许单向关闭(half-close)。也就是说，TCP连接关闭了一个方向的传输，成为一个单向连接(half-duplex)。第二个箭头和第三个箭头传递必须分开，才能有空隙在开放的方向上继续传输。如果第二个箭头和第三个箭头合并在一起，那么，随着一方关闭，另一方也要被迫关闭。</p><p>第二和第三次握手之间，server可以继续单向的发送片段给client，但client不能发送数据片段给server。(上面的终结从client先发起，TCP连接终结也可以从server先发起。)在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p></li></ul></li></ul><p><img src="/2019/07/23/Computer_Network/tcp.png" alt></p><ul><li><p>实现无差错的传输方案</p><ul><li><p>滑动窗口概念：自动重传请求协议（ARQ）为了方便存在自动重传协议（ARQ）</p></li><li><p><img src="/2019/07/23/Computer_Network/ARQ_protocol.png" alt></p></li></ul></li><li><p>TCP 流量控制(flow control)：接收方将advertised window size 通知发送方。发送方在收到window size的通知时，会调整自己的滑窗大小，使得发送速率降低，这样来减轻接收方的负担。出现零窗口的时候，发送方会不断探测接收方的窗口，窗口探测的时候，发送方会发送1byte大小的TCP片段，并且等待ACK回复(里面包含Win Size) </p></li><li><p>白痴窗口综合症 (Silly Window Syndrome) : 通信双方传输包含通信数据量很少，TCP头部的控制信息很多的情况。为了解决这个问题，需要从两方面入手。TCP中有相关的规定，要求：</p><ol><li><p>接收方宣告的窗口必须达到一定的尺寸，否则等待。</p></li><li><p>除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的TCP应用(比如命令行互动)。</p></li></ol></li><li><p>TCP重新发送机制</p><ul><li>TCP超时重传机制：重新发送超时时间(RTO, retransmission timeout），TCP协议中，通过采样RTT来得到合适的RTO时间</li><li>TCP快速重传机制：收到三次duplicate Ack的时候，发出方认为接收方没有收到，就进行重新传送之前没有传送的片段。</li></ul></li><li><p>TCP拥塞控制机制: 防止过多的数据注入到网络中，使得网络中的路由器和链路过载。</p><ul><li><p>TCP通过维护 Congestion Window Size 来进行拥塞控制。真实的滑窗大小取这两个的最小值，来满足拥塞控制和流量控制的要求。</p></li><li><p>TCP拥塞控制有这样四个算法</p><ul><li>slow start, congestion avoidance</li></ul></li></ul></li></ul><ul><li><p>快重传和快恢复算法</p></li><li><p>TCP的拥塞控制处于这样两个不同的状态，slow start 和 拥塞避免 congestion avoidance</p><p><img src="/2019/07/23/Computer_Network/congestionControl.png" alt></p><p>Congestion window从slow start的状态开始。Slow start的特点是初始速率低，但速率不断倍增。每次进入到slow start状态时，cwnd都需要重置为初始值1。发送方每接收到一个正确的ACK，就会将congestion window增加1，从而实现速率的倍增(由于<a href="http://www.cnblogs.com/vamei/archive/2012/12/18/2822739.html" target="_blank" rel="noopener">累计ACK</a>，速率增长可能会小于倍增)。</p><p>当congestion window的大小达到某个阈值ssthresh时，congestion进入到congestion avoidance状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，将窗口尺寸增加1(实际上就是每个RTT增加1)。所以在congestion avoidance下，cwnd线性增长，增长速率慢。</p><p>  如果在congestion avoidance下有片段丢失，重新回到slow start状态，并将ssthresh更新为cwnd的一半。我们看到，sshthresh是slow start到congestion avoidance的切换点。而片段丢失是congestion avoidance到slow start的切换点。一开始sshthresh的值一般比较大，所以slow start可能在切换成congestion avoidance之前就丢失片段。这种情况下，slow start会重新开始，而ssthresh更新为cwnd的一半。</p><p>  总的来说，发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。</p><p>  拥塞控制存在不同的算法，来进行协调和调整。</p><p>  <img src="/2019/07/23/Computer_Network/congestion_control.png" alt></p></li><li><p>TCP粘包问题和nagle算法：发送端为了将数据更有效的发送到接收端，使用了优化算法nagle算法，将多次间隔较小的包且数据量较小的包合并成一个包，进行封包，这样的话，要求接收端采用合适的算法进行拆包。</p></li></ul><h5 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h5><ul><li>DNS协议是基于UDP的，DNS服务器中存储了域名和IP的关系。</li><li>DNS协议进行查找的时候，是按照域名中的顺序，一级一级的进行查找。</li><li>DNS Cache 缓存，在进行查找之前，计算机会先查询cache中是否有相关的记录。</li><li>反向DNS，和DNS的顺序相反，提供IP所对应的域名。</li></ul><h5 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h5><ul><li><p>HTTP 报文</p><ul><li>基本格式：起始行（start line），头信息(headers) 空行 主体信息</li><li>起始行只有一行，请求表示求什么，回复表示发生什么。</li><li>头信息是多行，每一行都是键值对。</li><li>主体部分表示包含的具体资源。</li></ul></li><li><p>HTTP 状态码</p><ul><li>2xx 成功： 200 成功</li><li>3xx 重定向： 301 永久移动 302 临时移动</li><li>4xx 请求错误：404 未找到</li><li>5xx 服务器错误： 500 服务器内部错误</li></ul></li><li><p>HTTP 1.0 和 1.1 的区别</p><ul><li>引入了持久连接，在同一个TCP连接中可以传输多个<code>HTTP</code>请求和响应</li><li>多个请求和响应可以同时进行&amp;可以重叠</li><li>引入了更多的请求头和响应头</li></ul></li><li><p>HTTP 请求方法</p><ul><li>OPTIONS，HEAD， GET（请求的参数需要放置在URL中），POST（向指定资源提交数据进行处理请求），PUT(向指定资源位置上传新内容)，DELETE(请求服务器删除指定资源)，TRACE(回显收到的请求)，</li><li>GET请求和POST请求区别：URL上面回显，数据安全性，幂等性。</li></ul></li><li><p>HTTP 请求过程</p><ul><li>客户端连接到Web服务器：浏览器与Web服务器建立TCP连接</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放TCP连接：connection模式为close, 服务器主动关闭TCP连接； connection 模式为keepalive，则连接会维持一会儿</li></ul></li><li><p>HTTP 长连接和短连接</p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><img src="http_connection.png" alt></p></li><li><p>转发和重定向的区别：转发是服务器的行为，重定向是客户端的行为</p></li><li><p>Cookie  &amp; Session &amp; Token </p><ul><li>Cookie: 一种客户端机制<br><img src="/2019/07/23/Computer_Network/Cookie.png" alt><ul><li>为了辨别用户身份，进行session追踪而储存在本地客户端上面的数据（通常加密）</li><li>分为内存cookie (浏览器关闭后就消失了)，硬盘cookie（存在过期时间，超时或者用户手动清理）</li></ul></li></ul></li></ul><ul><li>持久性Cookie和非持久性Cookie</li><li>Session: 代表服务器和客户端一次会话过程，过程可以是连续的，可以是断续的。Session由服务器端生成并进行保存。<ul><li>判断用户是否登录 &amp; 购物车功能</li><li>Token:<br><img src="/2019/07/23/Computer_Network/Token.png" alt><ul><li>Token 由服务器返回给客户端，之后客户端每次请求都必须带上Token, 服务器端进行验证Token的有效性。</li></ul></li></ul></li></ul><h5 id="DHCP协议-动态主机配置协议"><a href="#DHCP协议-动态主机配置协议" class="headerlink" title="DHCP协议 (动态主机配置协议)"></a>DHCP协议 (动态主机配置协议)</h5><ul><li>要求： 地址合法和地址空闲</li><li>过程：Discovery(客户机广播)，Offer(DHCP服务器发出邀请，提供一个可用的IP地址)，Request(客户机正式请求使用该地址)，Acknowledge(DHCP服务器确认，并提供更多的参数)</li><li>其他网络配置信息，DNS服务器地址，网络出口地址</li><li>DHCP攻击： 拒绝攻击（DHCP耗尽攻击），伪造恶意的DHCP服务（中间人攻击，借助ARP欺诈），</li></ul><h5 id="SSL-TLS-协议"><a href="#SSL-TLS-协议" class="headerlink" title="SSL/TLS 协议"></a>SSL/TLS 协议</h5><ul><li><p>对称加密和非对称加密：使用相同的密匙或者使用不同的密匙。公私钥加密。</p></li><li><p>SSL协议: 使用非对称加密加密对称加密的密匙，使用对称加密的密匙加密传输的数据。</p><p>SSL协议的关键是用一个非常安全的方式来交换一个对称密钥。交换的过程会比上面的描述更加复杂一些。</p><ul><li>客户发起请求时，除了说明自己支持的非对称加密算法，还会附加一个客户端随机数(client random)。</li><li>服务器回复请求时，会确定非对称加密算法和哈希函数，并附上公钥。此外，服务器端还会在此次通信中附加一个服务器端随机数(server random)。</li><li>客户端会产生第三个随机数(Premaster secret)，然后利用服务器确定的非对称加密算法和公钥来加密这个随机数，再发送给服务器端。</li><li>客户端用自己的私钥解密第三个随机数。<br>这样，客户端和服务器端都知道了三个随机数。双方各自用商量好的哈希函数从三个随机数获得对称加密的密钥。</li></ul></li><li><p>HTTP 和 HTTPS 区别：</p><ul><li>HTTPS协议是由SSL+HTTP两个方面构建的可进行加密传输，身份认证的网络协议。相对于HTTP协议，HTTPS协议更加的安全。</li><li>HTTPS协议需要申请证书，一般的CA证书都需要收费。</li><li>HTTPS和HTTP使用不同的端口，HTTP使用80端口，HTTPS使用443端口。</li><li>HTTP工作在应用层，而HTTPS工作在传输层。</li></ul></li><li><p>https 通信过程</p><ul><li>A 与B 通过TCP 建立链接，初始化SSL 层。</li><li>进行SSL 握手，A 发送https 请求，传送客户端SSL 协议版本号、支持的加密算法、随机数等。</li><li>服务器B 把CA 证书（包含B 的公钥），把自己支持的加密算法、随机数等回传给A。</li><li>A 接收到CA 证书，验证证书有效性。</li><li>校验通过，客户端随机产生一个字符串作为与B通信的对称密钥，通过CA证书解出服务器B的公钥，对其加密，发送给服务器。</li><li>B 用私钥解开信息，得到随机的字符串（对称密钥），利用这个密钥作为之后的通信密钥。</li><li>客户端向服务器发出信息，指明后面的数据使用该对称密钥进行加密，同时通知服务器SSL 握手结束。</li><li>服务器接收到信息，使用对称密钥通信，通知握手接收。</li><li>SSL 握手结束，使用对称密钥加密数据。</li></ul></li><li><p>SSL工作原理：握手协议，警报协议，记录协议。</p></li></ul><h5 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h5><ul><li><p>SYN flood 攻击：给服务器发送了一个SYN之后就下线了，服务器需要等待63s之后才会断开连接，这样就会把主机的SYN连接给耗尽。使用三个参数进行处理，tcp_synack_retries 可以减少重试次数, tcp_max_syn_backlog, 可以增加SYN的连接数，tcp_abort_on_overflow处理不过来直接选择放弃。</p><ul><li>服务器的TCP资源分配时刻 = 完成第二次握手时，客户段进行TCP资源分配时刻在完成第三次握手时</li><li>攻击端利用伪造的IP地址向被攻击端进行攻击请求，而得到的报文不能发送到源地址，这样来耗尽服务器的资源，从而达到了攻击的目的。</li></ul></li><li><p>DDos 攻击：攻击者通过路由器发送海量的信息请求和畸形报文，导致CPU无法实时处理消息，引发正常的业务交互流程，内部处理流程阻塞，达到拒绝服务的目的。</p></li><li><p>DNS 欺诈：攻击者冒充域名服务器的一种行为。主要类别有主机host文件修改，本机DNS劫持。</p></li><li><p>ARP 投毒：通过分别伪装成客户机和服务器IP，将自己的MAC地址绑定在IP上，ARP错误的将IP解析为中间人MAC地址，从而来欺骗服务器网关和客户机，使信息必须通过客户机。</p></li><li><p>Replay 攻击：攻击者发送目标主机已接受的包，来达到欺骗系统的目的，主要用于身份认证的过程中，破坏认证的正确性。防范：加时间戳或者随机数。</p></li><li><p>Web Security</p><ul><li><p>SQL注入</p><ul><li>通过把SQL语句插入到Web表单提交或者是域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL语句的作用。</li><li>防范：加密处理输入，确保数据库安全（给予用户最低权限），输入验证（对于输入进行验证），参数分离，对于输入进行正则匹配验证。</li></ul></li><li><p>CSRF跨站请求伪造</p><ul><li>钓鱼网站盗用了被害者的身份信息，强调的是盗用</li><li>常见防护方法： 验证HTTP reference 字段；添加随机生成的Token字段；使用验证码；尽量使用POST进行请求，不使用GET进行请求；HTTP头添加自定义属性。</li></ul></li><li><p>XSS 跨站脚本攻击： <a href="https://thief.one/2017/05/31/1/" target="_blank" rel="noopener">https://thief.one/2017/05/31/1/</a></p><ul><li><p>页面被插入了恶意脚本</p></li><li><p>类别：反射型XSS，存储型XSS(存储在云端服务器)，DOM型</p></li><li><p>危害: cookie劫持，后台进行增删查改等操作，钓鱼，XSS蠕虫，修改网页代码，利用网站进行重定向，获取用户信息。</p></li><li><p>XSS探针: <code>&#39;&#39;;!--&quot;&lt;XSS&gt;=&amp;{()}</code></p></li><li><p>防御： </p><ul><li>可在cookie中设置httponly（浏览器禁止页面的js访问带有httponly属性的cookie）</li><li>xss filter（检查输入，设置白名单方式）</li><li>输出检查（编码，转义，常用编码：html编码，js编码，16进制等)</li><li>针对不同位置的输出，使用不同的处理方式</li><li>处理富文本</li><li>header中使用content-Sencurity-Policy字段，规定请求js的域名白名单（CSP策略）</li></ul></li></ul></li></ul></li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>浏览器中输入URL发生了什么<ul><li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器</li><li>浏览器向IP对应的web服务器发送一个HTTP请求</li><li>服务器响应请求，发回网页内容</li><li>浏览器解析网页内容</li></ul></li></ul><ul><li>网络命令<ul><li>ifconfig: 显示网络接口信息，如接口名称，接口类型，接口的IP地址，硬件的MAC地址等等。</li><li>arp -a: 显示本地存储的IP-MAC对应关系</li><li>sudo arp-scan -l：查询整个局域网内的所有IP地址的对应MAC地址</li><li>sudo tcpdump -i en0 arp：监听en0接口的arp协议通信</li><li>ping：是向某个IP地址发送ICMP协议的ECHO_REQUEST请求。收到该请求的设备，将返回ICMP回复。如果ping到某个IP地址，那么说明该IP地址的设备可以经网络层顺利到达</li><li>sudo ipconfig set en0 DHCP：更新DHCP租约。设备将释放IP地址，再从DHCP服务器重新获得IP地址。</li><li>netstat -nr: 显示路由表</li><li>traceroute 74.125.128.99：追踪到达IP目的地的全程路由</li><li>tcpdump是一款网络抓包工具。它可以监听网络接口不同层的通信，并过滤出特定的内容，比如特定协议、特定端口等</li><li>域名解析，调用DNS解析查看对应IP地址：host <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></li></ul></li><li>CDN （Content Delivery Network）内容分发网络<ul><li>定义：CDN，英文Content Delivery Network，中文翻译是内容分发网络，目的就是通过现有的Internet 中增加一新的网络架构，将网站内容发布到离用户最近的网络“边缘”，提高用户访问网站的速度，所以更像是增加了一层CACHE（缓存）层。</li><li>功能：当用户访问加入CDN 服务的网站时，域名解析请求将最终交给全局负载均衡DNS 进行处理。全局负载均衡DNS 通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。</li><li>组成：每个CDN 节点由两部分组成：负载均衡设备和高速缓存。</li></ul></li></ul><ul><li>参考资料<ul><li><a href="https://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html" target="_blank" rel="noopener">协议森林</a></li><li><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e" target="_blank" rel="noopener">搞定计算机网络面试</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/07/23/Computer_Network/Computer_Network.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
</feed>
