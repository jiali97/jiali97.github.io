<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git 实用指南]]></title>
    <url>%2F2019%2F08%2F08%2Fgit%2F</url>
    <content type="text"><![CDATA[最近用git结果傻了，不小心把东西给删了，一边抱怨自己的傻，脑子不够用，一边觉得是自己真心基本命令不熟，本来的版本管理现在只知道个push和pull，出了问题就不知道怎么对付，心疼自己，顺便出一份指南，省的之后忘了这个怎么用。 Git 简介Git，简而言之就是一个世界上最先进的分布式版本控制系统。CVS和SVN都是集中式的版本控制系统，版本都是存放在中央服务器中的，如果不能联网的话，就没有正确的代码。而分布式的系统中，每个人的电脑中都是一个完整的版本库。 Git原理 Git 获取仓库git init: 创建Git可以管理的仓库，当前目录下会多一个.git文件夹。 git clone /path/to/repo: 检出仓库。 git clone username@host:/path/to/repo: 从远程服务器中检出仓库。 Git 日常操作git add file : 计划改动，将文件提交到缓冲区中， 将对文件的修改提交到暂存区。合并遇到冲突时候，使用这个命令进行将文件标记为合并成功。 git commit -m &quot;message&quot;: 提交改动，将改动从缓冲区提交到HEAD，但是不是远程仓库。 git status: 查看仓库当前状态。 git diff &lt;filename&gt;: 查看当前对文件的修改内容（未提交到缓冲区）。 git log: 获取当前提交ID。显示从最近到最远的提交日志。--pretty=oneline 参数可以简化输出。--graph 可以查看分支合并图。 Git 时光穿梭git reset --hard HEAD^: HEAD表示最新版本，HEAD~100表示之前100个版本，HEAD^表示上一个版本，选择回退到那个版本。 git reflog: 记录每一次的git命令，选择去未来的那个版本。 git checkout -- &lt;filename&gt;: 将工作区的修改撤销，恢复到缓冲区或者是版本库。 git reset HEAD &lt;filename&gt;： 将暂存区的修改撤销，重新放回工作区。 rm &lt;filename&gt; &amp;&amp; git rm &lt;filename&gt;：删除文件。 Git 远程仓库git remote -v: 显示远程仓库， git remote add origin &lt;server&gt;: 将仓库连接到某个远程服务器。 git push origin &lt;master&gt;: 将改动提交到了远程仓库中，可以切换为想要推送的不同分支。 （可以使用-u参数对于本地仓库和远程仓库进行关联） git pull: 将工作目录的代码获取并合并远程的改动。 git push出现冲突的时候：需要先git pull 把最新的提交从分支中扒下来，然后在本地合并，解决冲突，在推送。 git branch --set-upstream-to=origin/dev dev: 将本地特定分支和远程dev分支进行绑定。 git rebase: 将分叉的提交历史变成一条直线 Git 分支管理git branch: 查看当前分支。 git checkout -b feature_x: 新建一个叫做feature_x的分支，并且切换过去。 git branch feature_x &amp;&amp; git checkout feature_x git checkout master: 切换到主分支。 git checkout -d feature_x: 删除新建的分支。 git checkout -D feature_x: 强制删除未合并分支。 git merge &lt;branch&gt;: 合并其他分支到当前分支， 使用--no-ff参数来 禁用Fast Forward模式并追加-m commit添加Commit。 git diff &lt;source_branch&gt; &lt;feature_branch&gt;: 进行两个分支的比较。 git stach: 将当前工作现场保存下来，等之后恢复现场后可以继续工作。 git stash list: 将工作现场列表显示出来。 git stash pop = git stash apply &amp;&amp; git stash pop: 处理之前的工作现场。 Git 标签管理 Git 的标签就是一个和commit 挂钩，并且有意义的名字。 git tag: 查看所有标签。 git tag -a &lt;1.0.0&gt; &lt;commit_id&gt; -m &lt;comment&gt;: 给某次提交打标签。 git tag -d v0.1: 删除本地标签。 git push origin &lt;tagname&gt;: 将标签提交到远程。 git push origin --tags: 将全部标签提交到远程。 git push origin:refs/tags/&lt;tagname&gt;: 删除远程标签 git show &lt;tagname&gt;: 查看标签信息。 git fetch origin &amp;&amp; git reset --hard origin/master： 放弃当前修改，从服务器上获取最新修改，并将本地分支指向它。 Git 其他.gitignore文件 Reference 廖雪峰的Git教程 Git 简明指南]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java && Python 算法面试常用类以及方法总结]]></title>
    <url>%2F2019%2F07%2F30%2FJava-data-structure%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 知识点总结]]></title>
    <url>%2F2019%2F07%2F26%2FJava%2F</url>
    <content type="text"><![CDATA[这篇是参考Java快速教程之后的一份学习笔记 基础Hello World 到面向对象 类(class)：上面程序定义了一个类HelloWorld，该类的名字与.java文件的名字相同。 方法(method)：类的内部定义了该类的一个方法main。 语句(statement)：真正的“打印”功能由一个语句实现，即: System.out.println(“Hello World!”); 使用javac编译，使用java运行 Java不同变量类型在程序中的内存分布 类型 存储大小 例值 注释 byte 1byte 3 字节 int 4bytes 3 整数 short 2bytes 3 短整数 long 8bytes 3 长整数 float 4bytes 1.2 单精度浮点数 double 8bytes 1.2 双精度浮点数 char 2bytes ‘a’ 字符 boolean 1bit true 布尔值 Java 数组声明和定义 声明：int[] a; 声明的同时使用new来创建数组所需空间：int[] a = new int[100]; 声明创建同时指定元素内容：int[] a = new int[]{1,3,5,7,9}; 表达式 数学表达式： +,-,*,/,% 关系表达式：&gt;,&gt;=,==,&lt;=,&lt;,!= 布尔表达式：&amp;&amp;,||,! 位运算：&amp;,|,^,~,&lt;&lt;,&gt;&gt; 双目表达式：condition? X1:X2 控制结构 选择结构 if else switch 循环结构： while do{} while() for(){} break continue 方法和数据对象 Java 使用return来返回值 this 指代的是对象本身 成员方法可以添加参数列表 使用 this.method() 调用同一对象的其他方法 显式初始化：声明对象时候，对于对象进行赋值 构造器以及重载 构造器定义函数值： 类似于C语言中的构造函数 构建方法 &gt; 显式初始值 &gt; 默认初始值 Java根据方法名和参数列表决定要调用的方法，叫做方法重载 封装和接口 三种不同的封装方法 public private protected： 标记为protected的成员变量在该类和该类的衍生类中可见，但不能被外界访问。 interface 接口 interface 可以定义接口 implements 可以实现接口 可以实现一个类 实现多个接口 has-a 关系 一个对象可以拥有另一个对象 (手电筒有电池) package : 将Java程序代码进行打包，使用包进行访问 JVM，实现程序的可移植性 extends 继承 新类称之为衍生类 同名同参数方法会存在方法覆盖 使用super访问父层的方法 基类对象先被创建和进行初始化，结束之后，开始构建衍生层(衍生层对象进行创建和初始化) 类数据和类方法 类数据对象： 所有成员进行共享的变量 使用关键字 static 类方法：操作类对象的方法使用关键字static, 使用这个关键字的方法不能正常操作属于对象的数据和方法 对象方法可以访问类数据 final 关键字：这个数据 / 类 / 方法不能被改变了, private 方法默认为final方法 接口继承和抽象类 接口的继承： 和类的继承类似， 可以添加设计更多的方法，不同点，可以实现多重继承 抽象类：只提供类的原型，不提供类的具体实现。 Java 对象引用 new 在内存中为对象开辟了空间，在内存的堆上开辟了空间。 对象引用存储在内存的栈中 当我们将一个引用赋值给另一个引用的时候，我们实际上复制的是对象的地址，两个引用将操作同一个对象。当程序通过一个引用修改了对象之后，通过其他引用课也可以看到该修改。 垃圾回收机制：当一个对象没有引用指向的时候，这个对象就会被清空。 Java 参数传递：Java的参数传递为值传递。当我们传递一个参数时，方法将获得该参数的一个拷贝。 基本对象的参数传递：传递的是值的拷贝，Java方法不会影响到值，形式变量和实际变量。 引用值的参数传递： 传递的是对象的地址，Java方法会直接影响到对象。 类型转换和多态 类型检查 基本类型检查： 收缩类型变换（强制类型转换），宽松变换(自动进行) Upcast 和多态：一个衍生类可以转换为其基类引用 一个衍生类对象可以当做一个基类对象使用 所有对象都有一个共同的继承祖先，Object类 进阶String 类 创建字符串 不需要new关键字 Java String 类别中的常用方法 方法 效果 s.length() 返回字符串s的长度 s.charAt() 返回字符串中下标为2的字符 s.substring(0,4) 返回s字符串中下标0-4的子字符串 s.indexOf(“Hello”) 返回子字符串”Hello“的下标 s.startsWith(“ “) 返回s是否以空格开始 s.endsWith(“oo”) 判断s是否以”oo”结束 s.equals(“Good World!”) 判断s是否等于”Good World!”， ==只能判断字符串是否保存在同一位置。需要使用equals()判断字符串的内容是否相同。 s.compareTo(“Hello Nerd!”) 比较s字符串与”Hello Nerd!”在词典中的顺序，返回一个整数，如果&lt;0，说明s在”Hello Nerd!”之前；如果&gt;0，说明s在”Hello Nerd!”之后；如果==0，说明s与”Hello Nerd!”相等。 s.trim() 去掉s前后的空格字符串，并返回新的字符串 s.toUpperCase() 将s转换为大写字母，并返回新的字符串 s.toLowerCase() 将s转换为小写字母，并返回新的字符串 s.replace(“World”, “Universe”) 将”World”替换为”Universe”，并返回新的字符串 String 类型对象是不可变对象 异常处理 try, catch, finally 以及其随后的代码段来组成，finally 不是必须的 try后面的程序块包含了针对该异常类型所要进行的操作。try所监视的程序块可能抛出不止一种类型的异常，所以一个异常处理器可以有多个catch模块。finally后面的程序块是无论是否发生异常，都要执行的程序。 异常都来自与Throwable类，一个Throwable类对象可以抛出，异常分为unchecked 异常和checked异常。 Error是指Java的内部错误或者是资源耗尽等错误，需要直接退出程序。 Exception里面一个衍生类RuntimeException 都是程序自身的问题组成的。 checked 异常，是由编程与环境 可以自己新建类，在程序中抛出异常 可以自定义异常，使用继承的方式，需要小心选择所继承的基类。 运行时类别识别（RTTI） Class类：对类的抽象和集合。当我们调用对象的getClass()的时候，就会得到其对应Class对象的引用 Class类方法 getName() 返回类的名字 getPackage()返回类所在的包 getFields()返回所有的public数据成员 getMethods()返回所有的public方法 多线程 多线程是计算机实现多任务并行处理的一种方式 单核CPU会在不同的任务之间做切换，这是操作系统分时复用的机制 多个线程可以并存于同一个进程空间。在JVM的一个进程空间中，一个栈(stack)代表了方法调用的次序。对于多线程来说，进程空间中需要有多个栈，以记录不同线程的调用次序。多个栈互不影响，但所有的线程将共享堆(heap)中的对象。 Thread基类的构造方法可以使用一个字符串作为参数，该字符串是该线程的名字，并使用getName()返回。 我们调用线程对象的start() 方法启动线程 join(Thread tr)： 等待线程tr完成 setDaemon(): 设置当前线程为后台daemon 另一种实现多线程的方法是实现Runable接口，并提供run()方法 Synchronized: 进程之间的同步，防止出现超票的情况 我们将共享的资源置于一个对象中 对于共享资源的操作，放在synchronized方法中 容器 数组 在说明类型时，在类型说明后面增加一个[]，来说明是一个数组。 使用new创建容器时，需要说明数组的大小。我们可以使用 数组名[下标] 的方式来调用某个元素。 我们可以逐个的初始化数组的元素，也可以在声明的同时使用{}初始化数组。 使用System.arraycopy()方法来有效的复制数组 12System.arraycopy(aFrom, 1, aTo, 0, 3);//aFrom为想要复制出去的数组，aTo为想要复制到的数组，1为aFrom的想要复制出去的元素起始位置，0为aTo中想要存储复制来元素的起始位置，3为所要复制的元素总数。 Collection List 表 容器的引用为List类型， 但是容器的实施类型为ArrayList类型。 将接口和实施做分离 123456import java.util.*;List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();add();//方法加入新的元素get();//方法可以获取容器中的元素，传递一个整数下标作为参数remove();//方法可以删除容器中的元素，传递一个整数下标作为参数。(有另一个remove()，传递元素自身作为参数)size();//方法用来返回容器中元素的总数 Set 集合 集合中不允许有等值的元素 集合的元素没有顺序 Map 键值对的集合 Collection 主要方法: 1234567891011boolean add(Object o);//添加对象到集合boolean addAll(Collection c);//将指定 collection 中的所有元素都添加到此 collection 中（可选操作void clear();//删除集合中所有元素boolean remove(Object o);//删除指定的对象boolean removeAll(Collection c);//移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。boolean retainAll(Collection c);//仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。int size();//返回当前集合中元素的数量boolean contains(Object o);//查找集合中是否有指定的对象boolean containsAll(Collection c);//查找集合中是否有集合c中的元素boolean isEmpty();//判断集合是否为空Iterator iterator();//返回一个迭代器 iterator 接口：不论Collection 的实际类型是什么，都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子可以逐一访问Collection里面的元素。 123boolean hasNext(); //如果仍有元素可以迭代，则返回TrueE next(); //返回下一个迭代的元素void next(); //将迭代器指向的集合中，移除迭代器返回的最后一个元素 List 接口： 有序的Collection，使用这个接口可以精确的控制每个元素插入的位置，用户可以使用索引（下标的方式）对于对象进行访问。 LinkedList 类：允许null元素，提供额外的get,remove,insert 方法，并不是线程安全的，注意它没有同步方法，需要自己新建。 ArrayList类：实现了一个大小可变的数组，允许null元素，没有同步方法。 快速添加删除，使用LinkedList，需要快速随机访问元素，使用ArrayList类 Vector类：类似于ArrayList，但是存在的同步方法，是线程安全的，使用Iterator进行遍历操作时候，不同线程对于同一个对象操作会产生异常。` Stack类：继承自Vector, 实现了一个后进先出的栈，提供5个额外的方法使得Vector能够当做栈来使用，push, pop,peek, empty,search，刚开始创建的时候是空栈。 Set接口： 不包含重复元素的Collection HashSet: 方法有add(),remove(元素) ，旗下还有实现类LinkedHashSet TreeSet: 是Set的一种变体，可以实现按照树型进行插入，实现元素的排序（从小到大） Map接口: 没有实现Collection类，提供从key到value的一种映射。 Map接口需要实现的方法有： put/putAll/remove/clear 增加删除 get/values 获取值 containKey/containValue 判断 entrySet/keySet 获取迭代 equals/hashcode 比较 HashMap 类: 非进程同步的 HashTable类：进程同步的 TreeMap类：Map数据是根据key来进行排序的 嵌套类 内部类 Java 允许我们在一个类中嵌套另一个类， 在类的内部定义一个新类，这个类称为内部类 内部类是被认为是外部对象的一个成员，在定义内部类的时候，同样有访问权限控制（public, private, protected） 内部类的默认访问权限是包访问权限，我们可以在外部测试类中访问到对象的内部类，并使用该内部类创建对象。 1Human.Cup soloCup = me.new Cup(); 在创建对象的时候，要注意必须基于一个外部类，并使用这个外部类对象来创建Cup对象。 闭包 内部类对象必须依附于某个外部类对象，与此同时，内部类对象也可以访问到它所依附的外部类对象的成员（即便是private成员）。从另一个角度来讲，内部类对象附带有创建对象时的环境信息。 嵌套static类 我们可以定义嵌套的static类，对象不需要依附于外部类的某个对象。相应的，这个嵌套类也无法调用外部对象的方法，也无法读取或者修改外部对象的数据。效果上看，就是扩展了类的命名空间。 GUI 图形界面以及事件响应 Java GUI 功能主要集中在awt和swing中。awt是GUI的底层包。 Java Layout 布局方式：Java 里面存在着不同的布局方式。Java布局方式 元素，事件，监听器： 通过监听器，可以将事件绑定在图形元素上面 ActionListener, ActionEvent class 内存管理和垃圾回收 Java 是在JVM所虚拟出来的内存环境中运行的。 内存分为栈stack和堆heap 两个部分 栈 记录了线程的方法调用，每个线程有一个栈 如果有新的方法调用，那么栈会增长 栈的存储单元为帧（frame） 栈中保存基本变量类型的变量值，以及对象的引用，引用指向堆 调用结束之后，栈会被释放 堆 堆的空间不会随着方法调用结束而清空，因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。 垃圾回收 Garbage Collection (GC) 垃圾回收负责释放不可到达的对象（即没有引用的指向的对象） 早期垃圾回收采用引用计数机制，但是存在循环引用不可处理的问题 “mark and sweep”： 这种机制下，每个对象将有标记信息，用于表示该对象是否可到达。当垃圾回收启动时，Java程序暂停运行。JVM从根出发，找到所有的可到达对象，并标记(mark)。随后，JVM需要扫描整个堆，找到剩余的对象，并清空这些对象所占据的内存。 “copy and sweep”。这种机制下，堆被分为两个区域。对象总存活于两个区域中的一个。当垃圾回收启动时，Java程序暂停运行。JVM从根出发，找到可到达对象，将可到达对象复制到空白区域中并紧密排列，修改由于对象移动所造成的引用地址的变化。最后，直接清空对象原先存活的整个区域，使其成为新的空白区域。 这两种机制， “mark and sweep”, “copy and sweep” 都是通过分代回收来进行回收的。 每个对象会记录它的世代信息，世代就是指对该对象所经历的垃圾分类回收的次数，世代越久远的对象，在内存中存活的时间就越长。 在上图中，堆分为三代，其中永久世代不会被垃圾回收，里面存储的是Class和类相关的信息。年轻世代和成熟世代需要进行垃圾回收。年轻世代需要分为三个区域，第一个区域叫做伊甸，新生对象将存在于这个区域。from, to: 这两个区域大小相等，相当于copy and sweep中的两个区域。当新建对象无法放入eden区时，将出发minor collection。JVM采用copy and sweep的策略，将eden区与from区的可到达对象复制到to区。经过一次垃圾回收，eden区和from区清空，to区中则紧密的存放着存活对象。随后，from区成为新的to区， to区成为新的from区。如果进行minor collection的时候，发现to区放不下，则将部分对象放入成熟世代。另一方面，即使to区没有满，JVM依然会移动世代足够久远的对象到成熟世代。 参考资料 Java 快速教程]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Network 知识点总结]]></title>
    <url>%2F2019%2F07%2F23%2FComputer_Network%2F</url>
    <content type="text"><![CDATA[基础 计算机中的二进制数 原码：使用最高位表示符号，后面表示数据大小 补码：正数和原码相同，负数为去除符号位的各位取反，末尾加一得到。（类似于计算机计算中的取模） 反码：原码各位（除了符号位）取反 移码：补码，符号位取反 计算机网络定义： 将不同地理位置，具有独立功能的多台计算机及网络设备通过通信线路（包括传输介质和网络设备）连接起来，在网络操作系统，网络管理软件及网络通信协议的共同管理和协调下实现资源共享和信息传递的计算机系统 计算机网络的基本组成 硬件系统：计算机设备，传输介质，网络设备。 软件系统：操作系统，网络通信协议 互联网体系结构 五层体系结构（转载自https://www.cnblogs.com/vamei/archive/2012/11/24/2773967.html） 物理层： 是指光纤、电缆或者电磁波等真实存在的物理媒介。这些媒介可以传送物理信号，比如亮度、电压或者振幅。对于数字应用来说，我们只需要两种物理信号来分别表示0和1，比如用高电压表示1，低电压表示0，就构成了简单的物理层协议。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为0/1序列。 连接层：信息以帧(frame)为单位传输。所谓的帧，是一段有限的0/1序列。连接层协议的功能就是识别0/1序列中所包含的帧。比如说，根据一定的0/1组合识别出帧的起始和结束。在帧中，有收信地址(Source, SRC)和送信地址(Destination, DST)，还有能够探测错误的校验序列(Frame Check Sequence)。当然，帧中最重要的最重要是所要传输的数据 (payload)。 这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(Type)信息。连接层协议不关心数据中到底包含什么。帧就像是一个信封，把数据包裹起来。数据帧中包括，SRC, DST, 数据，纠错码。Ethernet 以太网和WiFi 是现行的常见的连接层协议。 网络层：不同的社区之间该如何通信呢？ 换句话说，如何让WiFi上的一台计算机和以太网上的另一台计算机通信呢？我们需要一个“中间人”。这个“中间人”必须有以下功能: 1. 能从物理层上在两个网络的接收和发送0/1序列，2. 能同时理解两种网络的帧格式。路由器(router)就是为此而产生的“翻译”。一个路由器有多个网卡(NIC，Network Interface Controller)，每个NIC可以接入多个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。所以路由器就像是在两个社区都有分支的邮局一个社区的邮差将信送到本社区的邮局分支，而邮局会通过自己在另一个地区的分支将信转交给另一个社区的邮差手中，并由另一个社区的邮差最终送到目的地。 传输层：上面的三层协议让不同的计算机之间可以通信。但计算机中实际上有许多个进程，每个进程都可能有通信的需求(参看Linux进程基础和Linux进程间通信)。这就好像一所房子里住了好几个人(进程)，如何让信精确的送到某个人手里呢？遵照之前相同的逻辑，我们需要在信纸上写上新的信息，比如收信人的姓名，才可能让信送到。所以，传输层就是在信纸的空白上写上新的“收信人”信息。每一所房子会配备一个管理员(传输层协议)。管理员从邮差手中接过信，会根据“收信人”，将信送给房子中的某个人。 传输层协议，比如TCP和UDP，使用端口号(port number)来识别收信人(某个进程)。在写信的时候，我们写上目的地的端口。当信到达目的地的管理员手中，他会根据传输层协议，识别端口号，将信送给不同的人。TCP和UDP协议是两种不同的传输层协议。UDP协议类似于我们的信件交流过程。TCP协议则好像两个情人间的频繁通信。一个小情人要表达的感情太多，以致于连续写了好几封信。而另一方必须将这些信按顺序排列起来，才能看明白全部的意思。TCP协议还有控制网络交通等功能。 应用层：通过上面的几层协议，我们已经可以在任意两个人(进程)之间进行通信。然而每个人实际上从事的是不同的行业。有的人是律师，有的人外交官。比如说律师之间的通信，会用严格的律师术语，以免产生纠纷。再比如外交官之间的通信，必须符合一定的外交格式，以免发生外交误会。再比如间谍通过暗号来传递加密信息。应用层协议是对信件内容进一步的用语规范。应用层的协议包括用于Web浏览的HTTP协议，用于传输文件的FTP协议，用于Email的IMAP等等。 整个通信过程如下: WiFi上的计算机1-&gt;路由WiFi接口-&gt; 路由以太网接口-&gt; 以太网上的计算机2 (蓝色表示WiFi网络，绿色表示以太网络) 在连接层，我们的一个帧中只能记录SRC和DST两个地址。而上面的过程需要经过四个地址 (计算机1，WiFi接口，以太网接口，计算机2)。显然，仅仅靠连接层协议无法满足我们的需要。由于连接层协议开发在先，我们无法改动连接层协议，只能在连接层的数据(payload)，也就是信纸内部下功夫了。IP协议应运而生。 计算机1，路由器和计算机2都要懂得IP协议。当计算机1写信的时候，会在信纸的开头写上这封信的出发地址和最终到达地址 (而不是在信封上)，而在信封上写上要送往邮局。WiFi网的邮差将信送往邮局。在邮局，信被打开，邮局工作人员看到最终地址，于是将信包装在一个新的信封中，写上出发地为邮局，到达地为计算机2，并交给以太网的邮差，由以太网的邮差送往计算机2。 所以邮局要求，信纸上写的地址必须是一个符合官方规定的“邮编”，也就是IP地址。这个地址为世界上的每一个房子编号(邮编)。当信件送到邮局的时候，邮局根据邮编，就能查到对应的地址描述，从而能顺利改写信封上的信息。 每个邮局一般连接多个社区，而一个社区也可以有多个邮局，分别通往不同的社区。有时候一封信要通过多个邮局转交，才能最终到达目的地，这个过程叫做route。邮局将分离的局域网络连接成了internet，并最终构成了覆盖全球的互联网。 网络协议 连接层协议：Ethernet 以太网协议和WiFi协议 Ethernet 以太网协议 头部（preamble，SFD 起始信号，DST 目的地，SRC 发出地，Type 类型） 数据 （IP包） 尾部（FCS校验和（使用CRC校验）） 集线器（Hub）：广播式传播，不允许冲突，需要添加冲突处理算法。 交换机（Switch）:只向特定的网络接口中传播数据。 WiFi 协议(802.11协议) 网络层协议： 网卡： 网卡（Network Interface Card) 是计算机中的一个硬件，在接收到了网络信息之后，将信息交给计算机，当计算机需要发送信息的时候，也通过网卡发送。 路由器：就是配有多个网卡的硬件，帮助网卡接入不同的网络中。 IP协议： 不可靠。不能保证按序到达。 IPv4 =&gt; IPv6: 地址耗尽的危机 Version, Source Address, Destination Address: IP 协议版本，出发地IP和目的地IP Time to live =&gt; Hop Limit : 表示一个IP包的最大存活时间 Type of Service =&gt; Traffic Class: 为包分优先级， 后被分为Differentiated Service Field (DS, 前6位)和 Explicit Congestion Notification (ECN, 后2位) Protocol =&gt; Next Header: 包中所包含的协议是什么 IHL 记录头部长度，Total Length =&gt; Payload Length 表示IPv6数据部分的长度。 Header Checksum：校验IP头部信息。 Identification, flags和fragment offset: 为包的碎片化准备，包传播路径上面有MTU(最大传输单元) Flow Label (IPv6 中新增)： 提醒路由器来重复之前的接力路径，这样IP包可以保持出发的顺序。 RIP 协议(Routing Information Protocol)：通过距离来决定routing table. 通常在一个自治系统中使用。 BGP 协议(Boarder Gateway Protocol)：不同的 AS 相互沟通的协议。 为了应对地址不够用的危机，使用CIDR无类域间路由进行网络扩展，相当于每个IP多了一个配套的子网掩码。 NAT协议 基础NAT协议 NATP协议 介于网络层和传输层之间的协议：ICMP 协议， 主要作用是传输网络诊断信息。 ARP协议用于发现周边的IP地址和MAC地址的对应。然而，ARP协议只用于IPv4，IPv6并不使用ARP协议。IPv6包通过邻居探索(ND, Neighbor Discovery)来实现ARP的功能。ND的工作方式与ARP类似，但它基于ICMP协议。ICMP包有Neighbor Solicitation和Neighbor Advertisement类型。这两个类型分别对应ARP协议的询问和回复信息。 传递错误信息和咨询信息。ICMP协议是基于IP协议的。是实现ping命令和traceroute命令的基础。 常见的ICMP包类型 回音：Echo-询问类型包，Echo-回答类型包 源头冷却：提醒主机减慢发包速度。 目的地无法到达：可能不存在合适的路由或者是相对应接口没有开启。 超时：TTL减为0的时候，发生的错误就是超时错误。 重定向: 当一个路由器收到了一个IP包，对照其routing table,发现自己不应该收到该IP包，它会向主机发送重新定向类型的ICMP, 提醒出发主机修改自己的routing table. 传输层协议 UDP协议： 和IP协议非常相似，不可靠的，以数据包形式传输。 UDP分为头部，和数据部分两个部分。 UDP头部包括source port，destination port，Length 以及 Checksum 四个部分。 可以调用操作系统中的API，来构建socket。Socket是操作系统提供的一个编程接口，它用来代表某个网络通信。 TCP协议：传输层的流协议。可靠的协议。双向的。 滑动窗口协议代替单纯的stop and wait 协议：传输(Seq),等待(Ack) TCP需要两个IP，两个端口确定谁和谁在说话。同一个端口上可能有很多个连接。 应用层协议 基于TCP：FTP(文件传输协议，端口21)，Telnet(远程登录，支持BBS，端口23)， SMTP(简单邮件传输协议，端口25)，POP3(用于接受邮件的协议，端口110)，HTTP(超文本传输协议) 基于UDP：DNS(域名解析协议，端口53)， SNMP(简单网络管理协议，端口161)，TFTP(简单文件传输协议，端口69) TCP/IP 协议 TCP头部 TCP 连接 每个TCP片段都有自己的序号，ACK是一位，只有ACK设定的时候，回复号才生效，许多ACK回复的时候，是附着在其双向的连接中，也可以附着在SYN和FIN片段中。 TCP三次握手 ISN 交换 (Initial Sequence Number) 青色为纯粹的ACK片段。整个过程的本质是双方互发含有自己的ISN的SYN片段。根据TCP传输的规则，接收到ISN的一方需要回复ACK，所以共计四片信息在建立连接过程中传输。之所以是三次握手 (而不是四次)，是因为server将发送SYN和回复ACK合并到一个TCP片段中。我们以client方为例。client知道自己的ISN(也就是ISN(c))。建立连接之后，它也知道了对方的ISN(s)。此后，如果需要发送文本流片段，则编号为ISN(c) + 1, ISN(c) + 2 …。如果接收文本流片段，则期待接收ISN(s) + 1, ISN(s) + 2 …。连接建立之后，连接的双方就可以按照TCP传输的方式相互发送文本流了。 TCP 四次挥手 连接终结 一个连接建立之后，连接两端的进程可以利用该连接进行通信。当连接的一方觉得“我讲完了”，它可以终结连接中发送到对方方向的通信。连接最终通过四次握手(four-way handshaking)的方式终结，连接终结使用的是特殊片段FIN(FIN位为1的片段)。 我们可以看到，连接终结的过程中，连接双方也交换了四片信息(两个FIN和两个ACK)。在终结连接的过程中，TCP并没有合并FIN与ACK片段。原因是TCP连接允许单向关闭(half-close)。也就是说，TCP连接关闭了一个方向的传输，成为一个单向连接(half-duplex)。第二个箭头和第三个箭头传递必须分开，才能有空隙在开放的方向上继续传输。如果第二个箭头和第三个箭头合并在一起，那么，随着一方关闭，另一方也要被迫关闭。 第二和第三次握手之间，server可以继续单向的发送片段给client，但client不能发送数据片段给server。(上面的终结从client先发起，TCP连接终结也可以从server先发起。)在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 实现无差错的传输方案 滑动窗口概念：自动重传请求协议（ARQ）为了方便存在自动重传协议（ARQ） TCP 流量控制(flow control)：接收方将advertised window size 通知发送方。发送方在收到window size的通知时，会调整自己的滑窗大小，使得发送速率降低，这样来减轻接收方的负担。出现零窗口的时候，发送方会不断探测接收方的窗口，窗口探测的时候，发送方会发送1byte大小的TCP片段，并且等待ACK回复(里面包含Win Size) 白痴窗口综合症 (Silly Window Syndrome) : 通信双方传输包含通信数据量很少，TCP头部的控制信息很多的情况。为了解决这个问题，需要从两方面入手。TCP中有相关的规定，要求： 接收方宣告的窗口必须达到一定的尺寸，否则等待。 除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的TCP应用(比如命令行互动)。 TCP重新发送机制 TCP超时重传机制：重新发送超时时间(RTO, retransmission timeout），TCP协议中，通过采样RTT来得到合适的RTO时间 TCP快速重传机制：收到三次duplicate Ack的时候，发出方认为接收方没有收到，就进行重新传送之前没有传送的片段。 TCP拥塞控制机制: 防止过多的数据注入到网络中，使得网络中的路由器和链路过载。 TCP通过维护 Congestion Window Size 来进行拥塞控制。真实的滑窗大小取这两个的最小值，来满足拥塞控制和流量控制的要求。 TCP拥塞控制有这样四个算法 slow start, congestion avoidance 快重传和快恢复算法 TCP的拥塞控制处于这样两个不同的状态，slow start 和 拥塞避免 congestion avoidance Congestion window从slow start的状态开始。Slow start的特点是初始速率低，但速率不断倍增。每次进入到slow start状态时，cwnd都需要重置为初始值1。发送方每接收到一个正确的ACK，就会将congestion window增加1，从而实现速率的倍增(由于累计ACK，速率增长可能会小于倍增)。 当congestion window的大小达到某个阈值ssthresh时，congestion进入到congestion avoidance状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，将窗口尺寸增加1(实际上就是每个RTT增加1)。所以在congestion avoidance下，cwnd线性增长，增长速率慢。 如果在congestion avoidance下有片段丢失，重新回到slow start状态，并将ssthresh更新为cwnd的一半。我们看到，sshthresh是slow start到congestion avoidance的切换点。而片段丢失是congestion avoidance到slow start的切换点。一开始sshthresh的值一般比较大，所以slow start可能在切换成congestion avoidance之前就丢失片段。这种情况下，slow start会重新开始，而ssthresh更新为cwnd的一半。 总的来说，发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。 拥塞控制存在不同的算法，来进行协调和调整。 TCP粘包问题和nagle算法：发送端为了将数据更有效的发送到接收端，使用了优化算法nagle算法，将多次间隔较小的包且数据量较小的包合并成一个包，进行封包，这样的话，要求接收端采用合适的算法进行拆包。 DNS 协议 DNS协议是基于UDP的，DNS服务器中存储了域名和IP的关系。 DNS协议进行查找的时候，是按照域名中的顺序，一级一级的进行查找。 DNS Cache 缓存，在进行查找之前，计算机会先查询cache中是否有相关的记录。 反向DNS，和DNS的顺序相反，提供IP所对应的域名。 HTTP协议 HTTP 报文 基本格式：起始行（start line），头信息(headers) 空行 主体信息 起始行只有一行，请求表示求什么，回复表示发生什么。 头信息是多行，每一行都是键值对。 主体部分表示包含的具体资源。 HTTP 状态码 2xx 成功： 200 成功 3xx 重定向： 301 永久移动 302 临时移动 4xx 请求错误：404 未找到 5xx 服务器错误： 500 服务器内部错误 HTTP 1.0 和 1.1 的区别 引入了持久连接，在同一个TCP连接中可以传输多个HTTP请求和响应 多个请求和响应可以同时进行&amp;可以重叠 引入了更多的请求头和响应头 HTTP 请求方法 OPTIONS，HEAD， GET（请求的参数需要放置在URL中），POST（向指定资源提交数据进行处理请求），PUT(向指定资源位置上传新内容)，DELETE(请求服务器删除指定资源)，TRACE(回显收到的请求)， GET请求和POST请求区别：URL上面回显，数据安全性，幂等性。 HTTP 请求过程 客户端连接到Web服务器：浏览器与Web服务器建立TCP连接 发送HTTP请求 服务器接受请求并返回HTTP响应 释放TCP连接：connection模式为close, 服务器主动关闭TCP连接； connection 模式为keepalive，则连接会维持一会儿 HTTP 长连接和短连接 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 转发和重定向的区别：转发是服务器的行为，重定向是客户端的行为 Cookie &amp; Session &amp; Token Cookie: 一种客户端机制 为了辨别用户身份，进行session追踪而储存在本地客户端上面的数据（通常加密） 分为内存cookie (浏览器关闭后就消失了)，硬盘cookie（存在过期时间，超时或者用户手动清理） 持久性Cookie和非持久性Cookie Session: 代表服务器和客户端一次会话过程，过程可以是连续的，可以是断续的。Session由服务器端生成并进行保存。 判断用户是否登录 &amp; 购物车功能 Token: Token 由服务器返回给客户端，之后客户端每次请求都必须带上Token, 服务器端进行验证Token的有效性。 DHCP协议 (动态主机配置协议) 要求： 地址合法和地址空闲 过程：Discovery(客户机广播)，Offer(DHCP服务器发出邀请，提供一个可用的IP地址)，Request(客户机正式请求使用该地址)，Acknowledge(DHCP服务器确认，并提供更多的参数) 其他网络配置信息，DNS服务器地址，网络出口地址 DHCP攻击： 拒绝攻击（DHCP耗尽攻击），伪造恶意的DHCP服务（中间人攻击，借助ARP欺诈）， SSL/TLS 协议 对称加密和非对称加密：使用相同的密匙或者使用不同的密匙。公私钥加密。 SSL协议: 使用非对称加密加密对称加密的密匙，使用对称加密的密匙加密传输的数据。 SSL协议的关键是用一个非常安全的方式来交换一个对称密钥。交换的过程会比上面的描述更加复杂一些。 客户发起请求时，除了说明自己支持的非对称加密算法，还会附加一个客户端随机数(client random)。 服务器回复请求时，会确定非对称加密算法和哈希函数，并附上公钥。此外，服务器端还会在此次通信中附加一个服务器端随机数(server random)。 客户端会产生第三个随机数(Premaster secret)，然后利用服务器确定的非对称加密算法和公钥来加密这个随机数，再发送给服务器端。 客户端用自己的私钥解密第三个随机数。这样，客户端和服务器端都知道了三个随机数。双方各自用商量好的哈希函数从三个随机数获得对称加密的密钥。 HTTP 和 HTTPS 区别： HTTPS协议是由SSL+HTTP两个方面构建的可进行加密传输，身份认证的网络协议。相对于HTTP协议，HTTPS协议更加的安全。 HTTPS协议需要申请证书，一般的CA证书都需要收费。 HTTPS和HTTP使用不同的端口，HTTP使用80端口，HTTPS使用443端口。 HTTP工作在应用层，而HTTPS工作在传输层。 https 通信过程 A 与B 通过TCP 建立链接，初始化SSL 层。 进行SSL 握手，A 发送https 请求，传送客户端SSL 协议版本号、支持的加密算法、随机数等。 服务器B 把CA 证书（包含B 的公钥），把自己支持的加密算法、随机数等回传给A。 A 接收到CA 证书，验证证书有效性。 校验通过，客户端随机产生一个字符串作为与B通信的对称密钥，通过CA证书解出服务器B的公钥，对其加密，发送给服务器。 B 用私钥解开信息，得到随机的字符串（对称密钥），利用这个密钥作为之后的通信密钥。 客户端向服务器发出信息，指明后面的数据使用该对称密钥进行加密，同时通知服务器SSL 握手结束。 服务器接收到信息，使用对称密钥通信，通知握手接收。 SSL 握手结束，使用对称密钥加密数据。 SSL工作原理：握手协议，警报协议，记录协议。 网络安全 SYN flood 攻击：给服务器发送了一个SYN之后就下线了，服务器需要等待63s之后才会断开连接，这样就会把主机的SYN连接给耗尽。使用三个参数进行处理，tcp_synack_retries 可以减少重试次数, tcp_max_syn_backlog, 可以增加SYN的连接数，tcp_abort_on_overflow处理不过来直接选择放弃。 服务器的TCP资源分配时刻 = 完成第二次握手时，客户段进行TCP资源分配时刻在完成第三次握手时 攻击端利用伪造的IP地址向被攻击端进行攻击请求，而得到的报文不能发送到源地址，这样来耗尽服务器的资源，从而达到了攻击的目的。 DDos 攻击：攻击者通过路由器发送海量的信息请求和畸形报文，导致CPU无法实时处理消息，引发正常的业务交互流程，内部处理流程阻塞，达到拒绝服务的目的。 DNS 欺诈：攻击者冒充域名服务器的一种行为。主要类别有主机host文件修改，本机DNS劫持。 ARP 投毒：通过分别伪装成客户机和服务器IP，将自己的MAC地址绑定在IP上，ARP错误的将IP解析为中间人MAC地址，从而来欺骗服务器网关和客户机，使信息必须通过客户机。 Replay 攻击：攻击者发送目标主机已接受的包，来达到欺骗系统的目的，主要用于身份认证的过程中，破坏认证的正确性。防范：加时间戳或者随机数。 Web Security SQL注入 通过把SQL语句插入到Web表单提交或者是域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL语句的作用。 防范：加密处理输入，确保数据库安全（给予用户最低权限），输入验证（对于输入进行验证），参数分离，对于输入进行正则匹配验证。 CSRF跨站请求伪造 钓鱼网站盗用了被害者的身份信息，强调的是盗用 常见防护方法： 验证HTTP reference 字段；添加随机生成的Token字段；使用验证码；尽量使用POST进行请求，不使用GET进行请求；HTTP头添加自定义属性。 XSS 跨站脚本攻击： https://thief.one/2017/05/31/1/ 页面被插入了恶意脚本 类别：反射型XSS，存储型XSS(存储在云端服务器)，DOM型 危害: cookie劫持，后台进行增删查改等操作，钓鱼，XSS蠕虫，修改网页代码，利用网站进行重定向，获取用户信息。 XSS探针: &#39;&#39;;!--&quot;&lt;XSS&gt;=&amp;{()} 防御： 可在cookie中设置httponly（浏览器禁止页面的js访问带有httponly属性的cookie） xss filter（检查输入，设置白名单方式） 输出检查（编码，转义，常用编码：html编码，js编码，16进制等) 针对不同位置的输出，使用不同的处理方式 处理富文本 header中使用content-Sencurity-Policy字段，规定请求js的域名白名单（CSP策略） 其他 浏览器中输入URL发生了什么 查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器 浏览器向IP对应的web服务器发送一个HTTP请求 服务器响应请求，发回网页内容 浏览器解析网页内容 网络命令 ifconfig: 显示网络接口信息，如接口名称，接口类型，接口的IP地址，硬件的MAC地址等等。 arp -a: 显示本地存储的IP-MAC对应关系 sudo arp-scan -l：查询整个局域网内的所有IP地址的对应MAC地址 sudo tcpdump -i en0 arp：监听en0接口的arp协议通信 ping：是向某个IP地址发送ICMP协议的ECHO_REQUEST请求。收到该请求的设备，将返回ICMP回复。如果ping到某个IP地址，那么说明该IP地址的设备可以经网络层顺利到达 sudo ipconfig set en0 DHCP：更新DHCP租约。设备将释放IP地址，再从DHCP服务器重新获得IP地址。 netstat -nr: 显示路由表 traceroute 74.125.128.99：追踪到达IP目的地的全程路由 tcpdump是一款网络抓包工具。它可以监听网络接口不同层的通信，并过滤出特定的内容，比如特定协议、特定端口等 域名解析，调用DNS解析查看对应IP地址：host www.sina.com.cn CDN （Content Delivery Network）内容分发网络 定义：CDN，英文Content Delivery Network，中文翻译是内容分发网络，目的就是通过现有的Internet 中增加一新的网络架构，将网站内容发布到离用户最近的网络“边缘”，提高用户访问网站的速度，所以更像是增加了一层CACHE（缓存）层。 功能：当用户访问加入CDN 服务的网站时，域名解析请求将最终交给全局负载均衡DNS 进行处理。全局负载均衡DNS 通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。 组成：每个CDN 节点由两部分组成：负载均衡设备和高速缓存。 参考资料 协议森林 搞定计算机网络面试]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
</search>
